import type { Opaque } from 'ts-essentials';
import type { ZodTypeDef } from 'zod';
import { z } from 'zod';
import type { UserEtherscanKeys, UserEtherscanURLs, UserEtherscanURLsInput } from '../abi-management/etherscan/explorerEndpoints';
import { NetworkSymbol } from '../abi-management/networks';
import { NestedDict } from '../utils/utility-types';
export type { UserEtherscanURLs, UserEtherscanURLsInput };
export type AddressInput = `0x${string}`;
/** @internal */
export type Address = Opaque<AddressInput, 'Address'>;
/**
 * @see https://info.etherscan.com/what-is-an-ethereum-address/
 * @param address - string representation of an address
 * @returns the same string branded as Address if it's a valid address
 */
export declare function parseAddress(address: string): Address;
export type NestedAddresses = NestedDict<Address>;
export type NestedAddressesInput = NestedDict<AddressInput>;
export type EthSdkContracts = {
    [key in NetworkSymbol]?: NestedAddresses;
};
export type EthSdkContractsInput = {
    [key in NetworkSymbol | (string & {})]?: NestedAddressesInput;
};
export declare const ethSdKContractsSchema: z.ZodSchema<EthSdkContracts, ZodTypeDef, EthSdkContractsInput>;
export type RpcURLs = {
    [key in NetworkSymbol | (string & {})]?: string;
};
declare const abiSourceSchema: z.ZodUnion<[z.ZodLiteral<"etherscan">, z.ZodLiteral<"sourcify">]>;
export type AbiSource = z.infer<typeof abiSourceSchema>;
export type NetworkIds = {
    [key in NetworkSymbol | (string & {})]?: number;
};
export declare const networkIdsSchema: z.ZodSchema<NetworkIds>;
export declare const flagsSchema: z.ZodObject<{
    tsNocheck: z.ZodOptional<z.ZodBoolean>;
    discriminateTypes: z.ZodBoolean;
    alwaysGenerateOverloads: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    discriminateTypes: boolean;
    alwaysGenerateOverloads: boolean;
    tsNocheck?: boolean | undefined;
}, {
    discriminateTypes: boolean;
    alwaysGenerateOverloads: boolean;
    tsNocheck?: boolean | undefined;
}>;
declare const ethSdkConfigSchema: z.ZodObject<{
    contracts: z.ZodType<EthSdkContracts, ZodTypeDef, EthSdkContractsInput>;
    outputPath: z.ZodDefault<z.ZodString>;
    etherscanKey: z.ZodOptional<z.ZodString>;
    etherscanKeys: z.ZodDefault<z.ZodType<UserEtherscanKeys, ZodTypeDef, UserEtherscanKeys>>;
    etherscanURLs: z.ZodDefault<z.ZodType<UserEtherscanURLs, ZodTypeDef, UserEtherscanURLsInput>>;
    rpc: z.ZodDefault<z.ZodType<RpcURLs, ZodTypeDef, RpcURLs>>;
    noFollowProxies: z.ZodOptional<z.ZodBoolean>;
    abiSource: z.ZodDefault<z.ZodUnion<[z.ZodLiteral<"etherscan">, z.ZodLiteral<"sourcify">]>>;
    networkIds: z.ZodDefault<z.ZodType<NetworkIds, ZodTypeDef, NetworkIds>>;
    typechainFlags: z.ZodOptional<z.ZodObject<{
        tsNocheck: z.ZodOptional<z.ZodBoolean>;
        discriminateTypes: z.ZodBoolean;
        alwaysGenerateOverloads: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        discriminateTypes: boolean;
        alwaysGenerateOverloads: boolean;
        tsNocheck?: boolean | undefined;
    }, {
        discriminateTypes: boolean;
        alwaysGenerateOverloads: boolean;
        tsNocheck?: boolean | undefined;
    }>>;
}, "strict", z.ZodTypeAny, {
    contracts: EthSdkContracts;
    outputPath: string;
    etherscanKeys: UserEtherscanKeys;
    etherscanURLs: UserEtherscanURLs;
    rpc: RpcURLs;
    abiSource: "etherscan" | "sourcify";
    networkIds: NetworkIds;
    etherscanKey?: string | undefined;
    noFollowProxies?: boolean | undefined;
    typechainFlags?: {
        discriminateTypes: boolean;
        alwaysGenerateOverloads: boolean;
        tsNocheck?: boolean | undefined;
    } | undefined;
}, {
    contracts: EthSdkContractsInput;
    outputPath?: string | undefined;
    etherscanKey?: string | undefined;
    etherscanKeys?: UserEtherscanKeys | undefined;
    etherscanURLs?: UserEtherscanURLsInput | undefined;
    rpc?: RpcURLs | undefined;
    noFollowProxies?: boolean | undefined;
    abiSource?: "etherscan" | "sourcify" | undefined;
    networkIds?: NetworkIds | undefined;
    typechainFlags?: {
        discriminateTypes: boolean;
        alwaysGenerateOverloads: boolean;
        tsNocheck?: boolean | undefined;
    } | undefined;
}>;
/**
 * Type of *parsed* eth-sdk config.
 * @internal
 */
export interface EthSdkConfig extends z.infer<typeof ethSdkConfigSchema> {
}
/**
 * Type of eth-sdk config file contents.
 */
export type EthSdkConfigInput = z.input<typeof ethSdkConfigSchema>;
export declare function parseEthSdkConfig(data: unknown): {
    contracts: EthSdkContracts;
    outputPath: string;
    etherscanKeys: UserEtherscanKeys;
    etherscanURLs: UserEtherscanURLs;
    rpc: RpcURLs;
    abiSource: "etherscan" | "sourcify";
    networkIds: NetworkIds;
    etherscanKey?: string | undefined;
    noFollowProxies?: boolean | undefined;
    typechainFlags?: {
        discriminateTypes: boolean;
        alwaysGenerateOverloads: boolean;
        tsNocheck?: boolean | undefined;
    } | undefined;
};
/** @internal */
export declare const createEthSdkConfig: (config: EthSdkConfigInput) => EthSdkConfig;
