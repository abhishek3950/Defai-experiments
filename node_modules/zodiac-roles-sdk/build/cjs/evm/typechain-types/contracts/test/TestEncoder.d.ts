import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedListener, TypedContractMethod } from "../../common";
export declare namespace TestEncoder {
    type _DynamicTupleStruct = {
        dynamic: BytesLike;
    };
    type _DynamicTupleStructOutput = [dynamic: string] & {
        dynamic: string;
    };
    type DynamicTupleStruct = {
        dynamic: BytesLike;
        _static: BigNumberish;
        dynamic32: BigNumberish[];
    };
    type DynamicTupleStructOutput = [
        dynamic: string,
        _static: bigint,
        dynamic32: bigint[]
    ] & {
        dynamic: string;
        _static: bigint;
        dynamic32: bigint[];
    };
    type StaticTupleStruct = {
        a: BigNumberish;
        b: AddressLike;
    };
    type StaticTupleStructOutput = [a: bigint, b: string] & {
        a: bigint;
        b: string;
    };
    type DynamicTupleWithArrayStruct = {
        a: BigNumberish;
        b: BytesLike;
        c: TestEncoder.StaticTupleStruct[];
    };
    type DynamicTupleWithArrayStructOutput = [
        a: bigint,
        b: string,
        c: TestEncoder.StaticTupleStructOutput[]
    ] & {
        a: bigint;
        b: string;
        c: TestEncoder.StaticTupleStructOutput[];
    };
    type DynamicTupleWithDynamicTupleStruct = {
        a: BytesLike;
        b: TestEncoder.StaticTupleStruct;
        c: BigNumberish;
        d: TestEncoder.DynamicTupleStruct;
    };
    type DynamicTupleWithDynamicTupleStructOutput = [
        a: string,
        b: TestEncoder.StaticTupleStructOutput,
        c: bigint,
        d: TestEncoder.DynamicTupleStructOutput
    ] & {
        a: string;
        b: TestEncoder.StaticTupleStructOutput;
        c: bigint;
        d: TestEncoder.DynamicTupleStructOutput;
    };
    type DynamicTupleWithStaticTupleStruct = {
        a: BigNumberish;
        b: BytesLike;
        c: TestEncoder.StaticTupleStruct;
    };
    type DynamicTupleWithStaticTupleStructOutput = [
        a: bigint,
        b: string,
        c: TestEncoder.StaticTupleStructOutput
    ] & {
        a: bigint;
        b: string;
        c: TestEncoder.StaticTupleStructOutput;
    };
    type MultiDynamicTupleStruct = {
        a: BytesLike;
        b: BigNumberish;
        c: BytesLike;
        d: BigNumberish[];
    };
    type MultiDynamicTupleStructOutput = [
        a: string,
        b: bigint,
        c: string,
        d: bigint[]
    ] & {
        a: string;
        b: bigint;
        c: string;
        d: bigint[];
    };
}
export interface TestEncoderInterface extends Interface {
    getFunction(nameOrSignature: "_dynamicTuple" | "arrayDynamicTupleItems" | "arrayStaticTupleItems" | "dynamic" | "dynamic32DynamicStatic" | "dynamicArray" | "dynamicStaticDynamic32" | "dynamicTuple" | "dynamicTupleWithNestedArray" | "dynamicTupleWithNestedDynamicTuple" | "dynamicTupleWithNestedStaticTuple" | "multiDynamicTuple" | "simple" | "staticDynamic" | "staticDynamicDynamic32" | "staticFn" | "staticTuple"): FunctionFragment;
    encodeFunctionData(functionFragment: "_dynamicTuple", values: [TestEncoder._DynamicTupleStruct]): string;
    encodeFunctionData(functionFragment: "arrayDynamicTupleItems", values: [TestEncoder.DynamicTupleStruct[]]): string;
    encodeFunctionData(functionFragment: "arrayStaticTupleItems", values: [TestEncoder.StaticTupleStruct[]]): string;
    encodeFunctionData(functionFragment: "dynamic", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "dynamic32DynamicStatic", values: [BytesLike[], string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "dynamicArray", values: [BytesLike[]]): string;
    encodeFunctionData(functionFragment: "dynamicStaticDynamic32", values: [BytesLike, boolean, BytesLike[]]): string;
    encodeFunctionData(functionFragment: "dynamicTuple", values: [TestEncoder.DynamicTupleStruct]): string;
    encodeFunctionData(functionFragment: "dynamicTupleWithNestedArray", values: [TestEncoder.DynamicTupleWithArrayStruct]): string;
    encodeFunctionData(functionFragment: "dynamicTupleWithNestedDynamicTuple", values: [TestEncoder.DynamicTupleWithDynamicTupleStruct]): string;
    encodeFunctionData(functionFragment: "dynamicTupleWithNestedStaticTuple", values: [TestEncoder.DynamicTupleWithStaticTupleStruct]): string;
    encodeFunctionData(functionFragment: "multiDynamicTuple", values: [TestEncoder.MultiDynamicTupleStruct]): string;
    encodeFunctionData(functionFragment: "simple", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "staticDynamic", values: [BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "staticDynamicDynamic32", values: [AddressLike, BytesLike, BigNumberish[]]): string;
    encodeFunctionData(functionFragment: "staticFn", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "staticTuple", values: [TestEncoder.StaticTupleStruct, BigNumberish]): string;
    decodeFunctionResult(functionFragment: "_dynamicTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "arrayDynamicTupleItems", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "arrayStaticTupleItems", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamic32DynamicStatic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicArray", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicStaticDynamic32", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicTupleWithNestedArray", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicTupleWithNestedDynamicTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicTupleWithNestedStaticTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "multiDynamicTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "simple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "staticDynamic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "staticDynamicDynamic32", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "staticFn", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "staticTuple", data: BytesLike): Result;
}
export interface TestEncoder extends BaseContract {
    connect(runner?: ContractRunner | null): TestEncoder;
    waitForDeployment(): Promise<this>;
    interface: TestEncoderInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    _dynamicTuple: TypedContractMethod<[
        arg0: TestEncoder._DynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    arrayDynamicTupleItems: TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    arrayStaticTupleItems: TypedContractMethod<[
        arg0: TestEncoder.StaticTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    dynamic: TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    dynamic32DynamicStatic: TypedContractMethod<[
        arg0: BytesLike[],
        arg1: string,
        arg2: BigNumberish
    ], [
        void
    ], "nonpayable">;
    dynamicArray: TypedContractMethod<[arg0: BytesLike[]], [void], "nonpayable">;
    dynamicStaticDynamic32: TypedContractMethod<[
        arg0: BytesLike,
        arg1: boolean,
        arg2: BytesLike[]
    ], [
        void
    ], "nonpayable">;
    dynamicTuple: TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    dynamicTupleWithNestedArray: TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleWithArrayStruct
    ], [
        void
    ], "nonpayable">;
    dynamicTupleWithNestedDynamicTuple: TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleWithDynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    dynamicTupleWithNestedStaticTuple: TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleWithStaticTupleStruct
    ], [
        void
    ], "nonpayable">;
    multiDynamicTuple: TypedContractMethod<[
        arg0: TestEncoder.MultiDynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    simple: TypedContractMethod<[arg0: BigNumberish], [void], "nonpayable">;
    staticDynamic: TypedContractMethod<[
        arg0: BigNumberish,
        arg1: BytesLike
    ], [
        void
    ], "nonpayable">;
    staticDynamicDynamic32: TypedContractMethod<[
        arg0: AddressLike,
        arg1: BytesLike,
        arg2: BigNumberish[]
    ], [
        void
    ], "nonpayable">;
    staticFn: TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    staticTuple: TypedContractMethod<[
        arg0: TestEncoder.StaticTupleStruct,
        arg1: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "_dynamicTuple"): TypedContractMethod<[
        arg0: TestEncoder._DynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "arrayDynamicTupleItems"): TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "arrayStaticTupleItems"): TypedContractMethod<[
        arg0: TestEncoder.StaticTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "dynamic"): TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "dynamic32DynamicStatic"): TypedContractMethod<[
        arg0: BytesLike[],
        arg1: string,
        arg2: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "dynamicArray"): TypedContractMethod<[arg0: BytesLike[]], [void], "nonpayable">;
    getFunction(nameOrSignature: "dynamicStaticDynamic32"): TypedContractMethod<[
        arg0: BytesLike,
        arg1: boolean,
        arg2: BytesLike[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "dynamicTuple"): TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "dynamicTupleWithNestedArray"): TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleWithArrayStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "dynamicTupleWithNestedDynamicTuple"): TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleWithDynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "dynamicTupleWithNestedStaticTuple"): TypedContractMethod<[
        arg0: TestEncoder.DynamicTupleWithStaticTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "multiDynamicTuple"): TypedContractMethod<[
        arg0: TestEncoder.MultiDynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "simple"): TypedContractMethod<[arg0: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "staticDynamic"): TypedContractMethod<[
        arg0: BigNumberish,
        arg1: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "staticDynamicDynamic32"): TypedContractMethod<[
        arg0: AddressLike,
        arg1: BytesLike,
        arg2: BigNumberish[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "staticFn"): TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "staticTuple"): TypedContractMethod<[
        arg0: TestEncoder.StaticTupleStruct,
        arg1: BigNumberish
    ], [
        void
    ], "nonpayable">;
    filters: {};
}
