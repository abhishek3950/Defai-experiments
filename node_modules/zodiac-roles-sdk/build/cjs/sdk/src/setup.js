"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setUpRolesMod = exports.setUpRoles = void 0;
const ethers_1 = require("ethers");
const typechain_types_1 = require("../../evm/typechain-types");
const annotations_1 = require("./annotations");
const poster_1 = require("./annotations/poster");
const calls_1 = require("./calls");
const permissions_1 = require("./permissions");
const roleKey_1 = require("./roleKey");
const ROLES_MASTERCOPY_ADDRESS = "0x9646fDAD06d3e24444381f44362a3B0eB343D337";
const PROXY_FACTORY_ADDRESS = "0x000000000000aDdB49795b0f9bA5BC298cDda236";
const DEFAULT_MULTISEND_ADDRESSES = [
    "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526", // https://github.com/safe-global/safe-deployments/blob/5ec81e8d7a85d66a33adbe0c098068c0a96d917c/src/assets/v1.4.1/multi_send.json
    "0x9641d764fc13c8B624c04430C7356C1C7C8102e2", // https://github.com/safe-global/safe-deployments/blob/5ec81e8d7a85d66a33adbe0c098068c0a96d917c/src/assets/v1.4.1/multi_send_call_only.json
];
const RolesInterface = typechain_types_1.Roles__factory.createInterface();
/**
 * Applies the given `roles` configurations to the Roles mod at `address`.
 *
 * **Warning:** This function does not check if any of the roles are already configured on the Roles mod. It will not revoke any permissions or members from existing roles.
 **/
const setUpRoles = ({ address, roles, }) => {
    // calls for configuring roles permissions
    const applyPermissionsCalls = roles.flatMap(({ key, permissions }) => {
        const { targets, annotations } = (0, permissions_1.processPermissions)(permissions);
        return [
            ...(0, calls_1.encodeCalls)((0, roleKey_1.encodeRoleKey)(key), (0, calls_1.grant)(targets)).map((data) => ({
                to: address,
                data,
                value: "0",
            })),
            ...(annotations.length > 0
                ? [
                    {
                        to: poster_1.POSTER_ADDRESS,
                        data: (0, poster_1.encodeAnnotationsPost)(address, (0, roleKey_1.encodeRoleKey)(key), (0, annotations_1.extendAnnotations)([], annotations)),
                        value: "0",
                    },
                ]
                : []),
        ];
    });
    // calls for setting up role members
    const rolesByMember = roles.reduce((acc, { key, members }) => {
        members.forEach((member) => {
            acc[member] = acc[member] || [];
            acc[member].push(key);
        });
        return acc;
    }, {});
    const assignRolesCalls = Object.entries(rolesByMember).map(([member, roleKeys]) => ({
        to: address,
        data: RolesInterface.encodeFunctionData("assignRoles", [
            member,
            roleKeys.map(roleKey_1.encodeRoleKey),
            roleKeys.map(() => true),
        ]),
        value: "0",
    }));
    return [...applyPermissionsCalls, ...assignRolesCalls];
};
exports.setUpRoles = setUpRoles;
const setUpRolesMod = ({ avatar, target = avatar, owner = avatar, roles = [], multiSendAddresses = DEFAULT_MULTISEND_ADDRESSES, enableOnTarget = true, saltNonce = "0x0000000000000000000000000000000000000000000000000000000000000000", }) => {
    // call for deploying the Roles mod proxy instance
    const setUpCalldata = typechain_types_1.Roles__factory.createInterface().encodeFunctionData("setUp", [
        ethers_1.AbiCoder.defaultAbiCoder().encode(["address", "address", "address"], [owner, avatar, target]),
    ]);
    const deployModuleCalldata = typechain_types_1.ModuleProxyFactory__factory.createInterface().encodeFunctionData("deployModule", [ROLES_MASTERCOPY_ADDRESS, setUpCalldata, saltNonce]);
    const deployModuleCall = {
        to: PROXY_FACTORY_ADDRESS,
        data: deployModuleCalldata,
        value: "0",
    };
    // calculate deterministic proxy address for extra config calls
    const proxyAddress = calculateProxyAddress(setUpCalldata, saltNonce);
    // calls for setting up multiSend transaction unwrapping
    const MULTISEND_SELECTOR = "0x8d80ff0a";
    const MULTISEND_UNWRAPPER = "0x93B7fCbc63ED8a3a24B59e1C3e6649D50B7427c0";
    const setTransactionUnwrapperCalls = multiSendAddresses.map((address) => ({
        to: proxyAddress,
        data: RolesInterface.encodeFunctionData("setTransactionUnwrapper", [
            address,
            MULTISEND_SELECTOR,
            MULTISEND_UNWRAPPER,
        ]),
        value: "0",
    }));
    // calls for configuring members and permissions for all roles
    const setUpRolesCalls = (0, exports.setUpRoles)({ address: proxyAddress, roles });
    const enableOnTargetCall = {
        to: target,
        data: RolesInterface.encodeFunctionData("enableModule", [proxyAddress]),
        value: "0",
    };
    return [
        deployModuleCall,
        ...setTransactionUnwrapperCalls,
        ...setUpRolesCalls,
        ...(enableOnTarget ? [enableOnTargetCall] : []),
    ];
};
exports.setUpRolesMod = setUpRolesMod;
const calculateProxyAddress = (initData, saltNonce) => {
    const byteCode = "0x602d8060093d393df3363d3d373d3d3d363d73" +
        ROLES_MASTERCOPY_ADDRESS.toLowerCase().slice(2) +
        "5af43d82803e903d91602b57fd5bf3";
    const salt = (0, ethers_1.solidityPackedKeccak256)(["bytes32", "uint256"], [(0, ethers_1.solidityPackedKeccak256)(["bytes"], [initData]), saltNonce]);
    return (0, ethers_1.getCreate2Address)(PROXY_FACTORY_ADDRESS, salt, (0, ethers_1.keccak256)(byteCode));
};
