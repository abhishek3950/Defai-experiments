"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.allow = exports.EVERYTHING = void 0;
const ethSdk = __importStar(require("@gnosis-guild/eth-sdk-client"));
const ethers_1 = require("ethers");
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
// We import via alias to avoid double bundling of sdk functions
// eslint does not know about our Typescript path alias
// eslint-disable-next-line import/no-unresolved
const zodiac_roles_sdk_1 = require("zodiac-roles-sdk");
// For things that are not publicly exported we still use relative paths.
// Since these are mainly types, this won't blow up bundles.
const allowances_1 = require("../permissions/authoring/conditions/allowances");
const utils_1 = require("../permissions/utils");
const makeAllowFunction = (contract, name) => {
    const functionFragment = contract.interface.getFunction(name);
    const functionInputs = functionFragment.inputs;
    if (typeof contract.target !== "string" ||
        !contract.target.startsWith("0x")) {
        throw new Error("Only addresses as contract targets are supported");
    }
    return (...args) => {
        const scopings = args.slice(0, functionInputs.length);
        const hasScopings = scopings.some((s) => !!s);
        const options = (args[functionInputs.length] || {});
        const presetFunction = {
            targetAddress: contract.target,
            signature: functionFragment.format("sighash"),
            condition: hasScopings
                ? zodiac_roles_sdk_1.c.calldataMatches(scopings, functionInputs)()
                : undefined,
        };
        return applyOptions((0, utils_1.coercePermission)(presetFunction), options);
    };
};
const emptyCalldataMatches = {
    paramType: zodiac_roles_deployments_1.ParameterType.Calldata,
    operator: zodiac_roles_deployments_1.Operator.Matches,
    children: [],
};
/**
 * EthersWithinAllowance and CallWithinAllowance are global conditions that restrict the total Ether value sent or the call rate.
 * They must be appended as children of the root calldata matches node.
 */
const applyGlobalAllowance = (condition = emptyCalldataMatches, allowanceCondition) => {
    if (condition.paramType !== zodiac_roles_deployments_1.ParameterType.Calldata ||
        condition.operator !== zodiac_roles_deployments_1.Operator.Matches) {
        throw new Error("Global allowance can only be applied to calldata matches nodes");
    }
    return Object.assign(Object.assign({}, condition), { children: [...(condition.children || []), allowanceCondition] });
};
const applyOptions = (entry, options) => {
    let condition = entry.condition;
    if (options.etherWithinAllowance) {
        if (!options.send) {
            throw new Error("`etherWithinAllowance` can only be used if `send` is allowed");
        }
        condition = applyGlobalAllowance(condition, (0, allowances_1.etherWithinAllowance)(options.etherWithinAllowance)());
    }
    if (options.callWithinAllowance) {
        condition = applyGlobalAllowance(condition, (0, allowances_1.callWithinAllowance)(options.callWithinAllowance)());
    }
    return Object.assign(Object.assign({}, entry), { send: options.send, delegatecall: options.delegatecall, condition });
};
exports.EVERYTHING = Symbol("EVERYTHING");
const makeAllowContract = (contract) => {
    const allowEverything = (options) => {
        return Object.assign({ targetAddress: contract.target }, options);
    };
    // TODO use Proxy just like ethers v6
    // https://github.com/ethers-io/ethers.js/blob/main/src.ts/contract/contract.ts#L777
    const contractHasFunction = (prop) => {
        try {
            contract.getFunction(prop);
        }
        catch (error) {
            if (!(0, ethers_1.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                throw error;
            }
            return false;
        }
        return true;
    };
    return new Proxy({}, {
        get: (target, prop) => {
            if (prop === exports.EVERYTHING) {
                return allowEverything;
            }
            if (typeof prop !== "string") {
                return undefined;
            }
            if (contractHasFunction(prop)) {
                return makeAllowFunction(contract, prop);
            }
            return undefined;
        },
        has: (target, prop) => {
            if (typeof prop === "symbol") {
                return prop === exports.EVERYTHING;
            }
            return contractHasFunction(prop);
        },
    });
};
const mapSdk = (sdk) => {
    return Object.keys(sdk).reduce((acc, key) => {
        // for this check to work reliably, make sure ethers node_modules is not duplicated
        if (sdk[key] instanceof ethers_1.BaseContract) {
            acc[key] = makeAllowContract(sdk[key]);
        }
        else {
            acc[key] = mapSdk(sdk[key]);
        }
        return acc;
    }, {});
};
const uncapitalize = (s) => s.charAt(0).toLowerCase() + s.slice(1);
exports.allow = Object.keys(ethSdk).reduce((acc, sdkGetterName) => {
    if (sdkGetterName === "getContract")
        return acc;
    const network = uncapitalize(sdkGetterName.slice(3, -3));
    acc[network] = mapSdk(
    // eslint-disable-next-line import/namespace
    ethSdk[sdkGetterName](ethers_1.ethers.getDefaultProvider()));
    return acc;
}, {});
