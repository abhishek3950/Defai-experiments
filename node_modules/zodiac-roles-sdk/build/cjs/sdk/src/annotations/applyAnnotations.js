"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendAnnotations = exports.applyAnnotations = void 0;
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const groupBy_1 = require("../utils/groupBy");
const poster_1 = require("./poster");
/**
 * Returns a set of encoded call data to be sent to the Roles mod for updating the annotations of the given role.
 *
 * @param roleKey The key of the role to update
 * @param annotations Annotations to apply to the role
 * @param options Options for the update
 */
const applyAnnotations = async (roleKey, annotations, options) => {
    var _a, _b;
    const { address, mode } = options;
    const log = options.log === true ? console.log : options.log || undefined;
    let currentAnnotations;
    if ("currentAnnotations" in options && options.currentAnnotations) {
        currentAnnotations = options.currentAnnotations;
    }
    else {
        if ("chainId" in options && options.chainId) {
            const role = await (0, zodiac_roles_deployments_1.fetchRole)({
                chainId: options.chainId,
                address: address,
                roleKey,
            });
            if (!role) {
                throw new Error(`Role ${roleKey} not found on chain ${options.chainId}`);
            }
            currentAnnotations = role.annotations;
        }
        else {
            throw new Error("Either `currentAnnotations` or `chainId` must be specified");
        }
    }
    let updatePost;
    switch (mode) {
        case "replace":
            updatePost = replaceAnnotations(currentAnnotations, annotations);
            break;
        case "extend":
            updatePost = (0, exports.extendAnnotations)(currentAnnotations, annotations);
            break;
        case "remove":
            updatePost = removeAnnotations(currentAnnotations, annotations);
            break;
        default:
            throw new Error(`Invalid mode: ${options.mode}`);
    }
    const addCount = ((_a = updatePost.addAnnotations) === null || _a === void 0 ? void 0 : _a.reduce((acc, add) => acc + add.uris.length, 0)) ||
        0;
    const removeCount = ((_b = updatePost.removeAnnotations) === null || _b === void 0 ? void 0 : _b.length) || 0;
    if (addCount === 0 && removeCount === 0) {
        return [];
    }
    if (log) {
        const message = [
            addCount > 0 ? "add " + pluralize(addCount, "annotation") : undefined,
            removeCount > 0
                ? "remove " + pluralize(removeCount, "annotation")
                : undefined,
        ]
            .filter(Boolean)
            .join(", ");
        log(`ğŸ’¬ ${message[0].toUpperCase()}${message.slice(1)}`);
    }
    return [(0, poster_1.encodeAnnotationsPost)(address, roleKey, updatePost)];
};
exports.applyAnnotations = applyAnnotations;
const replaceAnnotations = (current, next) => {
    const removeAnnotations = current
        .map((annotation) => annotation.uri)
        .filter((uri) => !next.some((nextAnnotation) => nextAnnotation.uri === uri));
    const toAdd = next.filter((annotation) => !current.some((currentAnnotation) => currentAnnotation.uri === annotation.uri &&
        currentAnnotation.schema === annotation.schema));
    return {
        removeAnnotations,
        addAnnotations: groupAnnotations(toAdd),
    };
};
const extendAnnotations = (current, add) => {
    const toAdd = add.filter(({ uri, schema }) => !current.some((annotation) => annotation.uri === uri && annotation.schema === schema));
    return {
        addAnnotations: groupAnnotations(toAdd),
    };
};
exports.extendAnnotations = extendAnnotations;
const removeAnnotations = (current, remove) => {
    return {
        removeAnnotations: remove
            .map((annotation) => annotation.uri)
            .filter((uri) => current.some((annotation) => annotation.uri === uri)),
    };
};
const groupAnnotations = (annotations) => Object.entries((0, groupBy_1.groupBy)(annotations, (annotation) => annotation.schema)).map(([schema, annotations]) => ({
    schema,
    uris: annotations.map((annotation) => annotation.uri),
}));
const pluralize = (count, singular, plural = `${singular}s`) => {
    if (count === 1) {
        return `1 ${singular}`;
    }
    return `${count} ${plural}`;
};
