"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bitmask = exports.lte = exports.lt = exports.gte = exports.gt = exports.avatar = exports.eq = void 0;
const ethers_1 = require("ethers");
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const utils_1 = require("./utils");
/**
 * Asserts that the value from calldata is equal to the given value
 * @param value The reference value to encode
 */
const eq = (value) => (abiType) => {
    const type = ethers_1.ParamType.from(abiType);
    const structure = (0, utils_1.describeStructure)(type);
    return {
        paramType: (0, utils_1.parameterType)(type),
        operator: zodiac_roles_deployments_1.Operator.EqualTo,
        compValue: (0, utils_1.encodeValue)(value, type),
        children: structure.children,
    };
};
exports.eq = eq;
/**
 * Asserts that the value from calldata is equal to the avatar address configured on the Roles mod
 */
const avatar = (abiType) => {
    const type = ethers_1.ParamType.from(abiType);
    const structure = (0, utils_1.describeStructure)(type);
    return {
        paramType: (0, utils_1.parameterType)(type),
        operator: zodiac_roles_deployments_1.Operator.EqualToAvatar,
        children: structure.children,
    };
};
exports.avatar = avatar;
/**
 * Asserts that the value from calldata is greater than the given value
 * @param value The reference value to encode
 */
const gt = (value) => (abiType) => {
    const type = ethers_1.ParamType.from(abiType);
    if (!type.type.startsWith("uint") && !type.type.startsWith("int")) {
        throw new Error("`gt` is only supported for uint and int params");
    }
    return {
        paramType: zodiac_roles_deployments_1.ParameterType.Static,
        operator: type.type.startsWith("uint")
            ? zodiac_roles_deployments_1.Operator.GreaterThan
            : zodiac_roles_deployments_1.Operator.SignedIntGreaterThan,
        compValue: (0, utils_1.encodeValue)(value, abiType),
    };
};
exports.gt = gt;
/**
 * Asserts that the value from calldata is greater than or equal to the given value
 * @param value The reference value to encode
 */
const gte = (value) => (0, exports.gt)(BigInt(value) - BigInt(1));
exports.gte = gte;
/**
 * Asserts that the value from calldata is greater than the given value
 * @param value The reference value to encode
 */
const lt = (value) => (abiType) => {
    const type = ethers_1.ParamType.from(abiType);
    if (!type.type.startsWith("uint") && !type.type.startsWith("int")) {
        throw new Error("`lt` is only supported for uint and int params");
    }
    return {
        paramType: zodiac_roles_deployments_1.ParameterType.Static,
        operator: type.type.startsWith("uint")
            ? zodiac_roles_deployments_1.Operator.LessThan
            : zodiac_roles_deployments_1.Operator.SignedIntLessThan,
        compValue: (0, utils_1.encodeValue)(value, abiType),
    };
};
exports.lt = lt;
/**
 * Asserts that the value from calldata is less than or equal to the given value
 * @param value The reference value to encode
 */
const lte = (value) => (0, exports.lt)(BigInt(value) + BigInt(1));
exports.lte = lte;
/**
 * Asserts that the bits selected by the mask at the given bytes offset equal the given value
 */
const bitmask = ({ shift = 0, mask, value }) => (abiType) => {
    const paramType = (0, utils_1.parameterType)(ethers_1.ParamType.from(abiType));
    if (paramType !== zodiac_roles_deployments_1.ParameterType.Static &&
        paramType !== zodiac_roles_deployments_1.ParameterType.Dynamic) {
        throw new Error(`Bitmask can only be used for parameters with type Static or Dynamic, got: ${zodiac_roles_deployments_1.ParameterType[paramType]}`);
    }
    if (shift < 0 || shift >= 65536) {
        throw new Error("shift is out of range, must be between 0 and 65535");
    }
    const maskBytes = (0, ethers_1.getBytes)(mask);
    if (maskBytes.length > 15) {
        throw new Error("mask is too long, maximum length is 15 bytes");
    }
    const valueBytes = (0, ethers_1.getBytes)(value);
    if (maskBytes.length > 15) {
        throw new Error("value is too long, maximum length is 15 bytes");
    }
    return {
        paramType,
        operator: zodiac_roles_deployments_1.Operator.Bitmask,
        compValue: (0, ethers_1.hexlify)((0, ethers_1.concat)([
            (0, ethers_1.toBeHex)(shift, 2),
            zeroPadRight(maskBytes, 15),
            zeroPadRight(valueBytes, 15),
        ])),
    };
};
exports.bitmask = bitmask;
function zeroPadRight(value, length) {
    const result = new Uint8Array(length);
    result.set(value, 0);
    return result;
}
