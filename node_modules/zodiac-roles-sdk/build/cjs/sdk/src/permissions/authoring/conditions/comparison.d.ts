import { BigNumberish, BytesLike } from "ethers";
import { ConditionFunction } from "./types";
/**
 * Asserts that the value from calldata is equal to the given value
 * @param value The reference value to encode
 */
export declare const eq: (value: any) => ConditionFunction<any>;
/**
 * Asserts that the value from calldata is equal to the avatar address configured on the Roles mod
 */
export declare const avatar: ConditionFunction<string>;
/**
 * Asserts that the value from calldata is greater than the given value
 * @param value The reference value to encode
 */
export declare const gt: (value: BigNumberish) => ConditionFunction<BigNumberish>;
/**
 * Asserts that the value from calldata is greater than or equal to the given value
 * @param value The reference value to encode
 */
export declare const gte: (value: BigNumberish) => ConditionFunction<BigNumberish>;
/**
 * Asserts that the value from calldata is greater than the given value
 * @param value The reference value to encode
 */
export declare const lt: (value: BigNumberish) => ConditionFunction<BigNumberish>;
/**
 * Asserts that the value from calldata is less than or equal to the given value
 * @param value The reference value to encode
 */
export declare const lte: (value: BigNumberish) => ConditionFunction<BigNumberish>;
/**
 * Asserts that the bits selected by the mask at the given bytes offset equal the given value
 */
export declare const bitmask: ({ shift, mask, value }: Bitmask) => ConditionFunction<BytesLike>;
interface Bitmask {
    /** Offset in bytes at which to apply the mask, defaults to `0` */
    shift?: number;
    /** The 15 bytes bitmask, each `1` means the bit at that position will be compared against the comparison value bit at the same position  */
    mask: BytesLike;
    /** The 15 bytes comparison value, defines the expected value (`0` or `1`) for the bit at that position */
    value: BytesLike;
}
export {};
