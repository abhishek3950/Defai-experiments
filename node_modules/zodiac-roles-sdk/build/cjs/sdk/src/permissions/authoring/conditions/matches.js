"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.abiEncodedMatches = exports.calldataMatches = exports.matches = void 0;
exports.mapScoping = mapScoping;
const ethers_1 = require("ethers");
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const checkConditionIntegrity_1 = require("../../../conditions/checkConditionIntegrity");
const utils_1 = require("../../utils");
const branching_1 = require("./branching");
const comparison_1 = require("./comparison");
const utils_2 = require("./utils");
/**
 * Matches a tuple or array against a structure of conditions.
 *
 * Throws if the type is not a tuple or array. Throws if the structure of conditions is incompatible with the type.
 * @param scoping The conditions on the tuple or array elements
 */
const matches = (scoping) => (abiType) => {
    // The type system allows for nesting matches(matches()).
    // While using this in practice would not make too much sense, we must make sure it's valid nonetheless.
    if (typeof scoping === "function") {
        return scoping(abiType);
    }
    let conditions;
    if (abiType.baseType === "tuple" && !abiType.components) {
        throw new Error("Tuple type must have components");
    }
    if (abiType.baseType === "array" && !abiType.arrayChildren) {
        throw new Error("Array type must have arrayChildren");
    }
    if (Array.isArray(scoping)) {
        // scoping is an array (TupleScopings)
        // supported for tuple and array types
        if (abiType.baseType !== "tuple" && abiType.baseType !== "array") {
            throw new Error(`Can only use \`matches\` on tuple or array type params, got: ${abiType.type}`);
        }
        // map scoping items to conditions
        conditions = scoping.map((scoping, index) => mapScoping(scoping, abiType.baseType === "tuple"
            ? abiType.components[index]
            : abiType.arrayChildren));
    }
    else {
        // scoping is an object (StructScoping)
        // only supported for tuple types
        if (abiType.baseType !== "tuple") {
            throw new Error(`Can only use \`matches\` with scoping object on tuple type params, got: ${abiType.type}`);
        }
        // map scoping values to conditions
        conditions = abiType.components.map((componentType) => mapScoping(scoping[componentType.name], componentType));
    }
    // sanity checks
    assertValidConditionsLength(conditions, abiType);
    assertValidConditionsKeys(scoping, abiType);
    assertCompatibleParamTypes(conditions, abiType);
    return {
        paramType: (0, utils_2.parameterType)(abiType),
        operator: zodiac_roles_deployments_1.Operator.Matches,
        children: conditions.map((condition, index) => condition ||
            (0, utils_2.describeStructure)(abiType.baseType === "tuple"
                ? abiType.components[index]
                : abiType.arrayChildren)),
    };
};
exports.matches = matches;
const calldataMatchesScopings = (scopings, abiTypes, selector) => (abiType) => {
    const paramTypes = abiTypes.map((abiType) => ethers_1.ParamType.from(abiType));
    // only supported at the top level or for bytes type params
    if (abiType && abiType.type !== "bytes") {
        throw new Error(`Can only use \`calldataMatches\` on bytes type params, got: ${abiType.type}`);
    }
    // map scoping items to conditions
    const conditions = paramTypes.map((type, index) => mapScoping(scopings[index], type));
    // sanity checks
    assertValidConditionsKeys(conditions, paramTypes);
    assertCompatibleParamTypes(conditions, paramTypes);
    const matchesCondition = {
        paramType: zodiac_roles_deployments_1.ParameterType.Calldata,
        operator: zodiac_roles_deployments_1.Operator.Matches,
        children: conditions.map((condition, index) => condition || (0, utils_2.describeStructure)(paramTypes[index])),
    };
    if (selector) {
        if (selector.length !== 10) {
            throw new Error(`Selector must be exactly 4 bytes long, got: ${selector.length}`);
        }
        return (0, branching_1.and)(() => matchesCondition, (0, comparison_1.bitmask)({ mask: "0xffffffff", value: selector }))(ethers_1.ParamType.from("bytes"));
    }
    return matchesCondition;
};
const calldataMatchesFunctionPermission = (functionPermission) => (abiType) => {
    // only supported at the top level or for bytes type params
    if (abiType && abiType.type !== "bytes") {
        throw new Error(`Can only use \`calldataMatches\` on bytes type params, got: ${abiType.type}`);
    }
    const { selector, condition } = (0, utils_1.coercePermission)(functionPermission);
    if (condition) {
        if (condition.operator !== zodiac_roles_deployments_1.Operator.Matches ||
            condition.paramType !== zodiac_roles_deployments_1.ParameterType.Calldata) {
            throw new Error(`calldataMatches expects a function permission with an \`Operator.matches\`, \`ParamType.Calldata\` condition, got: \`Operator.${zodiac_roles_deployments_1.Operator[condition.operator]}\`, \`ParamType.${zodiac_roles_deployments_1.ParameterType[condition.paramType]}\``);
        }
    }
    const selectorCondition = (0, comparison_1.bitmask)({
        mask: "0xffffffff0000000000000000000000",
        value: selector,
    });
    return (condition ? (0, branching_1.and)(() => condition, selectorCondition) : selectorCondition)(ethers_1.ParamType.from("bytes"));
};
const calldataMatches = (scopingsOrFunctionPermission, abiTypes, selector) => {
    return abiTypes
        ? calldataMatchesScopings(scopingsOrFunctionPermission, abiTypes, selector)
        : calldataMatchesFunctionPermission(scopingsOrFunctionPermission);
};
exports.calldataMatches = calldataMatches;
/**
 * Matches standard ABI encoded bytes against a structure of conditions.
 *
 * @param scoping The conditions structure over the decoded parameters
 * @param abiTypes The parameter types defining how to decode bytes
 **/
const abiEncodedMatches = (scopings, abiTypes) => (abiType) => {
    const paramTypes = abiTypes.map((abiType) => ethers_1.ParamType.from(abiType));
    // only supported at the top level or for bytes type params
    if (abiType && abiType.type !== "bytes") {
        throw new Error(`Can only use \`abiEncodedMatches\` on bytes type params, got: ${abiType.type}`);
    }
    // map scoping items to conditions
    const conditions = paramTypes.map((type, index) => mapScoping(scopings[index], type));
    // sanity checks
    assertValidConditionsKeys(conditions, paramTypes);
    assertCompatibleParamTypes(conditions, paramTypes);
    return {
        paramType: zodiac_roles_deployments_1.ParameterType.AbiEncoded,
        operator: zodiac_roles_deployments_1.Operator.Matches,
        children: conditions.map((condition, index) => condition || (0, utils_2.describeStructure)(paramTypes[index])),
    };
};
exports.abiEncodedMatches = abiEncodedMatches;
/**
 * Maps a scoping (shortcut notation or condition function) to a condition.
 * @param scoping The scoping to map.
 * @param abiType The abi type of the parameter the scoping applies to.
 * @returns
 */
function mapScoping(scoping, abiType) {
    if (scoping === undefined) {
        return undefined;
    }
    let conditionFunction;
    if (typeof scoping === "function") {
        // scoping is already a condition function
        conditionFunction = scoping;
    }
    else if (typeof scoping === "boolean" ||
        typeof scoping === "string" ||
        typeof scoping === "number" ||
        Array.isArray(scoping) ||
        isBigNumberish(scoping)) {
        // placeholders, primitive values, and arrays default to eq condition
        conditionFunction = (0, comparison_1.eq)(scoping);
    }
    else {
        // object values default to matches condition
        conditionFunction = (0, exports.matches)(scoping);
    }
    return conditionFunction(abiType);
}
const assertValidConditionsLength = (conditions, typeOrTypes) => {
    let expectedLength;
    if (Array.isArray(typeOrTypes)) {
        expectedLength = typeOrTypes.length;
    }
    else if (typeOrTypes.baseType === "tuple" && typeOrTypes.components) {
        expectedLength = typeOrTypes.components.length;
    }
    else if (typeOrTypes.baseType === "array") {
        expectedLength = typeOrTypes.arrayLength || -1;
    }
    else {
        throw new Error(`Can only use \`matches\` on tuple or array type params, got: \`${typeOrTypes.format("sighash")}\``);
    }
    if (expectedLength <= 0)
        return;
    if (conditions.length > expectedLength) {
        throw new Error(`The conditions structure has too many elements (expected length: ${expectedLength}, conditions length: ${conditions.length})`);
    }
};
const assertValidConditionsKeys = (structure, typeOrTypes) => {
    if (Array.isArray(structure))
        return;
    if (!Array.isArray(typeOrTypes) && typeOrTypes.baseType !== "tuple")
        return;
    const types = Array.isArray(typeOrTypes)
        ? typeOrTypes
        : typeOrTypes.components;
    const unusedStructureKeys = arrayDiff(Object.keys(structure), types.map((type) => type.name));
    if (unusedStructureKeys.length > 0) {
        throw new Error(`The conditions structure has unknown keys: ${unusedStructureKeys.join(", ")}`);
    }
};
const assertCompatibleParamTypes = (conditions, typeOrTypes) => {
    conditions.forEach((condition, index) => {
        if (!condition)
            return;
        let type;
        if (Array.isArray(typeOrTypes)) {
            type = typeOrTypes[index];
        }
        else if (typeOrTypes.baseType === "tuple" && typeOrTypes.components) {
            type = typeOrTypes.components[index];
        }
        else if (typeOrTypes.baseType === "array" && typeOrTypes.arrayChildren) {
            type = typeOrTypes.arrayChildren;
        }
        else {
            throw new Error(`Can only use \`matches\` on tuple or array type params, got: \`${typeOrTypes.format("sighash")}\``);
        }
        const expectedType = (0, utils_2.parameterType)(type);
        const scopedType = checkScopedType(condition);
        if (scopedType === expectedType)
            return;
        // allow dynamic type values to be interpreted as calldata or abi encoded
        if (expectedType === zodiac_roles_deployments_1.ParameterType.Dynamic &&
            (scopedType === zodiac_roles_deployments_1.ParameterType.Calldata ||
                scopedType === zodiac_roles_deployments_1.ParameterType.AbiEncoded)) {
            return;
        }
        const fieldReference = type.name ? `'${type.name}'` : `at index ${index}`;
        throw new Error(`Condition for field ${fieldReference} has wrong paramType \`${zodiac_roles_deployments_1.ParameterType[scopedType]}\` (expected: \`${zodiac_roles_deployments_1.ParameterType[expectedType]}\`)`);
    });
};
/**
 * Returns `condition.paramType` if it is not `ParameterType.None`, otherwise returns the scoped param type of its children, if any.
 * Throws if the children have mixed scoped param types.
 * @param condition The condition to get the scoped param type of.
 * @returns the `ParameterType` the condition is applied to.
 */
const checkScopedType = (condition) => {
    if (condition.paramType === zodiac_roles_deployments_1.ParameterType.None) {
        if (!condition.children || condition.children.length === 0) {
            // e.g.: Operator.EtherWithinAllowance / Operator.CallWithinAllowance
            return zodiac_roles_deployments_1.ParameterType.None;
        }
        const [first, ...rest] = condition.children;
        const result = checkScopedType(first);
        // assert that all following children have compatible types
        rest.forEach((child) => {
            const childType = checkScopedType(child);
            (0, checkConditionIntegrity_1.checkParameterTypeCompatibility)(result, childType);
        });
        return result;
    }
    return condition.paramType;
};
const arrayDiff = (a, b) => {
    const set = new Set(b);
    return a.filter((x) => !set.has(x));
};
function isBigNumberish(value) {
    return ((typeof value === "number" && value % 1 === 0) ||
        typeof value === "bigint" ||
        (typeof value === "string" && !!value.match(/^-?[0-9]+$/)) ||
        (0, ethers_1.isHexString)(value));
}
