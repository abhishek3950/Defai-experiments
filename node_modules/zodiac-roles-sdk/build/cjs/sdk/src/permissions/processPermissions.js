"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processPermissions = void 0;
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const conditions_1 = require("../conditions");
const groupBy_1 = require("../utils/groupBy");
const mergeFunctionPermissions_1 = require("./mergeFunctionPermissions");
const utils_1 = require("./utils");
/**
 * Processes permissions returning the resulting list of allowed targets. Merges permission entries addressing the same function and performs sanity checks.
 * @param permissions to process
 * @returns The resulting list of allowed targets
 */
const processPermissions = (permissions) => {
    const flatPermissions = permissions.flat();
    // first we merge permissions addressing the same target functions so every entry will be unique
    const uniquePermissions = (0, mergeFunctionPermissions_1.mergeFunctionPermissions)(flatPermissions);
    sanityCheck(uniquePermissions);
    // collect all fully cleared targets
    const fullyClearedTargets = uniquePermissions
        .filter((entry) => !(0, utils_1.isFunctionScoped)(entry))
        .map((entry) => ({
        address: entry.targetAddress.toLowerCase(),
        clearance: zodiac_roles_deployments_1.Clearance.Target,
        executionOptions: (0, utils_1.execOptions)(entry),
        functions: [],
    }));
    // collect all function scoped targets and bring conditions into the normal form
    const functionPermissions = uniquePermissions.filter((entry) => "selector" in entry);
    const functionScopedTargets = Object.entries((0, groupBy_1.groupBy)(functionPermissions, (entry) => entry.targetAddress)).map(([targetAddress, allowFunctions]) => ({
        address: targetAddress.toLowerCase(),
        clearance: zodiac_roles_deployments_1.Clearance.Function,
        executionOptions: zodiac_roles_deployments_1.ExecutionOptions.None,
        functions: allowFunctions.map((allowFunction) => {
            const { condition } = allowFunction;
            return {
                selector: allowFunction.selector,
                executionOptions: (0, utils_1.execOptions)(allowFunction),
                wildcarded: !condition,
                condition: condition && (0, conditions_1.normalizeCondition)(condition),
            };
        }),
    }));
    // collect all annotations
    const annotations = permissions
        .filter(isPermissionSet)
        .map((permissionSet) => permissionSet.annotation)
        .filter((annotation) => !!annotation);
    return {
        targets: [...fullyClearedTargets, ...functionScopedTargets],
        // make annotations unique
        annotations: annotations.filter((annotation, i) => annotations.findIndex((a) => a.uri === annotation.uri) === i),
    };
};
exports.processPermissions = processPermissions;
const sanityCheck = (permissions) => {
    assertNoWildcardScopedIntersection(permissions);
    assertNoDuplicateAllowFunction(permissions);
};
const assertNoWildcardScopedIntersection = (permissions) => {
    const wildcardTargets = permissions
        .filter((entry) => !(0, utils_1.isFunctionScoped)(entry))
        .map((entry) => entry.targetAddress);
    const scopedTargets = new Set(permissions.filter(utils_1.isFunctionScoped).map((entry) => entry.targetAddress));
    const intersection = [
        ...new Set(wildcardTargets.filter((x) => scopedTargets.has(x))),
    ];
    if (intersection.length > 0) {
        throw new Error(`An address can either be fully allowed or scoped to selected functions. The following addresses are both: ${intersection.join(", ")}`);
    }
};
const assertNoDuplicateAllowFunction = (permissions) => {
    const allowFunctions = permissions.filter(utils_1.isFunctionScoped).map(utils_1.targetId);
    const counts = allowFunctions.reduce((result, item) => (Object.assign(Object.assign({}, result), { [item]: (result[item] || 0) + 1 })), {});
    const duplicates = [
        ...new Set(allowFunctions.filter((item) => counts[item] > 1)),
    ];
    if (duplicates.length > 0) {
        throw new Error(`The following functions appear multiple times and cannot be merged: ${duplicates.join(", ")}.\nThis might be be due to different \`send\` and \`delegatecall\` flags in entries with the same target.`);
    }
};
const isPermissionSet = (p) => Array.isArray(p);
