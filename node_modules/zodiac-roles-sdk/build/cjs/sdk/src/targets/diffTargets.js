"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffTargets = void 0;
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const conditions_1 = require("../conditions");
/**
 *  Returns targets granted by `a` that are not granted by `b`
 */
const diffTargets = (a, b) => {
    // targets in a that are not in b
    const targetsDiff = a.filter((targetA) => !b.some((targetB) => targetsEqual(targetA, targetB)));
    // targets that are scoped in a and in b
    const scopedTargetsOverlap = a.filter((targetA) => targetA.clearance === zodiac_roles_deployments_1.Clearance.Function &&
        b.some((targetB) => targetsEqual(targetA, targetB)));
    // diff the functions of targets in the overlap
    const scopedTargetsOverlapDiff = scopedTargetsOverlap
        .map((targetA) => {
        const targetB = b.find((targetB) => targetsEqual(targetA, targetB));
        if (!targetB)
            throw new Error("invariant violation");
        return diffScopedTargets(targetA, targetB);
    })
        .filter(isTruthy);
    return [...targetsDiff, ...scopedTargetsOverlapDiff];
};
exports.diffTargets = diffTargets;
// Returns a diff of function-scoped targets, and undefined if the targets are equal
const diffScopedTargets = (targetA, targetB) => {
    // need to return early if functions are empty, so we don't handle this as an empty diff
    if (targetA.functions.length === 0 && targetB.functions.length > 0) {
        return targetA;
    }
    const functionsDiff = targetA.functions.filter((functionA) => !targetB.functions.some((functionB) => functionsEqual(functionA, functionB)));
    // if the functions diff is empty, we treat the targets as equal
    if (functionsDiff.length === 0)
        return undefined;
    return Object.assign(Object.assign({}, targetA), { functions: functionsDiff });
};
const targetsEqual = (targetA, targetB) => targetA.address.toLowerCase() === targetB.address.toLowerCase() &&
    targetA.clearance === targetB.clearance &&
    targetA.executionOptions === targetB.executionOptions;
const functionsEqual = (functionA, functionB) => functionA.selector === functionB.selector &&
    functionA.wildcarded === functionB.wildcarded &&
    functionA.executionOptions === functionB.executionOptions &&
    conditionsEqual(functionA.condition, functionB.condition);
const conditionsEqual = (conditionA, conditionB) => conditionA === conditionB ||
    (!conditionA && !conditionB) ||
    (conditionA &&
        conditionB &&
        (0, conditions_1.normalizeCondition)(conditionA).$$id === (0, conditions_1.normalizeCondition)(conditionB).$$id);
const isTruthy = Boolean;
