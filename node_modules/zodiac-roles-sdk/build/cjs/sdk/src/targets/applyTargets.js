"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceTargets = exports.applyTargets = void 0;
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const calls_1 = require("../calls");
const checkIntegrity_1 = require("./checkIntegrity");
const diffTargets_1 = require("./diffTargets");
/**
 * Returns a set of encoded call data to be sent to the Roles mod for updating the targets of the given role.
 *
 * @param roleKey The key of the role to update
 * @param targets Targets to apply to the role
 * @param options Options for the update
 */
const applyTargets = async (roleKey, targets, options) => {
    let currentTargets;
    if ("currentTargets" in options && options.currentTargets) {
        currentTargets = options.currentTargets;
    }
    else {
        if ("chainId" in options && options.chainId) {
            const role = await (0, zodiac_roles_deployments_1.fetchRole)({
                chainId: options.chainId,
                address: options.address,
                roleKey,
            });
            if (!role) {
                throw new Error(`Role ${roleKey} not found on chain ${options.chainId}`);
            }
            currentTargets = role.targets;
        }
        else {
            throw new Error("Either `currentTargets` or `chainId` and `address` must be specified");
        }
    }
    (0, checkIntegrity_1.checkIntegrity)(targets);
    let calls;
    switch (options.mode) {
        case "replace":
            calls = (0, exports.replaceTargets)(currentTargets, targets);
            break;
        case "extend":
            calls = extendTargets(currentTargets, targets);
            break;
        case "remove":
            calls = removeTargets(currentTargets, targets);
            break;
        default:
            throw new Error(`Invalid mode: ${options.mode}`);
    }
    if (options.log) {
        calls.forEach((call) => (0, calls_1.logCall)(call, options.log === true ? console.log : options.log || undefined));
    }
    return (0, calls_1.encodeCalls)(roleKey, calls);
};
exports.applyTargets = applyTargets;
const extendTargets = (current, add) => {
    // TODO if current grants a fully-cleared target, we need to remove function-scoped permissions to that target from add
    // TODO merge permissions to same target+function by joining their conditions with OR
    return (0, calls_1.grant)((0, diffTargets_1.diffTargets)(add, current));
};
/**
 * Computes the set of calls to update the current targets of a role to no longer include the targets passed for `subtract`.
 * @param current targets of the role that shall be updated
 * @param subtract targets to subtract from the current targets of the role
 * @returns The set of calls to make to the Roles modifier owning the role
 */
const removeTargets = (current, subtract) => {
    const notGranted = (0, diffTargets_1.diffTargets)(subtract, current);
    const toRevoke = (0, diffTargets_1.diffTargets)(subtract, notGranted);
    // TODO throw, if subtract contains a function to a target that is fully-cleared in current
    return (0, calls_1.revoke)(toRevoke);
};
/**
 * Computes the set of calls to update the targets of a role
 * @param current targets of the role that shall be updated
 * @param next targets of the role describing the desired target state
 * @returns The set of calls to make to the Roles modifier owning the role
 */
const replaceTargets = (current, next) => {
    return (0, calls_1.removeObsoleteCalls)([
        ...(0, calls_1.revoke)((0, diffTargets_1.diffTargets)(current, next)),
        ...(0, calls_1.grant)((0, diffTargets_1.diffTargets)(next, current)),
    ]);
};
exports.replaceTargets = replaceTargets;
