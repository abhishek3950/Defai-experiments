"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkIntegrity = void 0;
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const conditions_1 = require("../conditions");
const checkIntegrity = (targets) => {
    const uniqueAddresses = new Set(targets.map((target) => target.address.toLowerCase()));
    if (uniqueAddresses.size < targets.length) {
        throw new Error("Duplicate target addresses");
    }
    targets.forEach(checkTargetIntegrity);
};
exports.checkIntegrity = checkIntegrity;
const checkTargetIntegrity = (target) => {
    if (target.clearance === zodiac_roles_deployments_1.Clearance.Function &&
        target.functions.length === 0) {
        throw new Error(`Function-cleared targets must have at least one function (target in violation: ${target.address})`);
    }
    if (target.clearance !== zodiac_roles_deployments_1.Clearance.Function && target.functions.length > 0) {
        throw new Error(`A target with functions must be function-cleared (target in violation: ${target.address})`);
    }
    const uniqueFunctionSelectors = new Set(target.functions.map((func) => func.selector.toLowerCase()));
    if (uniqueFunctionSelectors.size < target.functions.length) {
        throw new Error(`Duplicate functions in target ${target.address}`);
    }
    target.functions.forEach(checkFunctionIntegrity);
};
const checkFunctionIntegrity = (func) => {
    if (func.wildcarded && func.condition) {
        throw new Error(`Wildcarded functions cannot have conditions (function in violation: ${func.selector})`);
    }
    if (!func.wildcarded && !func.condition) {
        throw new Error(`Non-wildcarded functions must have conditions (function in violation: ${func.selector})`);
    }
    if (func.condition) {
        (0, conditions_1.checkRootConditionIntegrity)(func.condition);
    }
};
