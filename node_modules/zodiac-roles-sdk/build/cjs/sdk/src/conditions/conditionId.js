"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.conditionAddress = exports.conditionId = void 0;
const ethers_1 = require("ethers");
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const encodeAbiParameters_1 = require("../utils/encodeAbiParameters");
const flattenCondition_1 = require("./flattenCondition");
const ERC2470_SINGLETON_FACTORY_ADDRESS = "0xce0042b868300000d44a59004da54a005ffdcf9f";
const ZERO_SALT = "0x0000000000000000000000000000000000000000000000000000000000000000";
const conditionId = (condition) => {
    const conditions = (0, flattenCondition_1.flattenCondition)(condition);
    return (0, ethers_1.concat)(conditions.flatMap((condition) => [
        packCondition(condition),
        condition.compValue || "0x",
    ]));
};
exports.conditionId = conditionId;
/**
 * Calculates the create2 storage address of the condition.
 */
const conditionAddress = (condition) => {
    const conditions = (0, flattenCondition_1.flattenCondition)(condition);
    removeExtraneousOffsets(conditions);
    const packed = (0, ethers_1.concat)([
        ...conditions.map((condition) => packCondition(condition)),
        ...conditions.map((condition) => packCompValue(condition)),
    ]);
    const initCode = initCodeFor(packed);
    return (0, ethers_1.getCreate2Address)(ERC2470_SINGLETON_FACTORY_ADDRESS, ZERO_SALT, (0, ethers_1.keccak256)(initCode)).toLowerCase();
};
exports.conditionAddress = conditionAddress;
// 8    bits -> parent
// 3    bits -> param type
// 5    bits -> operator
const offsetParent = 8;
const offsetParamType = 5;
const offsetOperator = 0;
const packCondition = (condition) => (0, ethers_1.toBeHex)((condition.parent << offsetParent) |
    (condition.paramType << offsetParamType) |
    (condition.operator << offsetOperator), 2);
const packCompValue = (condition) => {
    if (!hasCompValue(condition.operator))
        return "0x";
    if (!condition.compValue) {
        throw new Error(`compValue is required for operator ${zodiac_roles_deployments_1.Operator[condition.operator]}`);
    }
    return condition.operator === zodiac_roles_deployments_1.Operator.EqualTo
        ? (0, ethers_1.keccak256)(condition.compValue)
        : (0, encodeAbiParameters_1.encodeAbiParameters)(["bytes32"], [condition.compValue]);
};
const removeExtraneousOffsets = (conditions) => {
    for (let i = 0; i < conditions.length; i++) {
        if (conditions[i].compValue &&
            conditions[i].operator == zodiac_roles_deployments_1.Operator.EqualTo &&
            !isInline(conditions, i)) {
            conditions[i].compValue = "0x" + conditions[i].compValue.slice(66);
        }
    }
};
const isInline = (conditions, index) => {
    const paramType = conditions[index].paramType;
    switch (paramType) {
        case zodiac_roles_deployments_1.ParameterType.Static:
            return true;
        case zodiac_roles_deployments_1.ParameterType.Tuple:
            for (let j = index + 1; j < conditions.length; ++j) {
                const parent = conditions[j].parent;
                if (parent < index)
                    continue;
                if (parent > index)
                    break;
                if (!isInline(conditions, j)) {
                    return false;
                }
            }
            return true;
        default:
            return false;
    }
};
const initCodeFor = (bytecode) => (0, ethers_1.concat)([
    "0x63",
    (0, ethers_1.toBeHex)((0, ethers_1.dataLength)(bytecode) + 1, 4),
    "0x80600E6000396000F3",
    "0x00",
    bytecode,
]);
const hasCompValue = (operator) => operator >= zodiac_roles_deployments_1.Operator.EqualTo;
