"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitCondition = void 0;
const zodiac_roles_deployments_1 = require("zodiac-roles-deployments");
const normalizeCondition_1 = require("./normalizeCondition");
/**
 * Given two conditions, split the first condition into two conditions, the given split condition and the remainder.
 * @returns The remainder condition (normalized), or `undefined` if the split condition is equal to the combined condition.
 * @throws If the split condition is not a sub-condition of the combined condition.
 */
const splitCondition = (combined, split) => {
    var _a, _b, _c, _d;
    const combinedNormalized = (0, normalizeCondition_1.normalizeCondition)(combined);
    const splitNormalized = (0, normalizeCondition_1.normalizeCondition)(split);
    if (combinedNormalized.$$id === splitNormalized.$$id)
        return undefined;
    if (combinedNormalized.operator === zodiac_roles_deployments_1.Operator.Or) {
        // potential splitting point
        const combinedChildrenIds = new Set(((_a = combinedNormalized.children) === null || _a === void 0 ? void 0 : _a.map((c) => c.$$id)) || []);
        if (splitNormalized.operator === zodiac_roles_deployments_1.Operator.Or) {
            // n:m OR split
            const splitChildrenIds = new Set(((_b = splitNormalized.children) === null || _b === void 0 ? void 0 : _b.map((c) => c.$$id)) || []);
            if (new Set([...combinedChildrenIds, ...splitChildrenIds]).size !==
                combinedChildrenIds.size) {
                throw new Error("inconsistent children");
            }
            const remainderChildren = ((_c = combinedNormalized.children) === null || _c === void 0 ? void 0 : _c.filter((child) => !splitChildrenIds.has(child.$$id))) || [];
            if (!remainderChildren.length)
                return undefined;
            return remainderChildren.length === 1
                ? remainderChildren[0]
                : renormalize(Object.assign(Object.assign({}, combinedNormalized), { children: remainderChildren }));
        }
        else {
            // n:1 OR split
            if (!combinedChildrenIds.has(splitNormalized.$$id)) {
                throw new Error("inconsistent children");
            }
            const remainderChildren = ((_d = combinedNormalized.children) === null || _d === void 0 ? void 0 : _d.filter((child) => child.$$id !== splitNormalized.$$id)) || [];
            if (!remainderChildren.length)
                return undefined;
            return remainderChildren.length === 1
                ? remainderChildren[0]
                : renormalize(Object.assign(Object.assign({}, combinedNormalized), { children: remainderChildren }));
        }
    }
    if (combinedNormalized.operator !== splitNormalized.operator) {
        throw new Error("inconsistent operators");
    }
    if (combinedNormalized.paramType !== splitNormalized.paramType) {
        throw new Error("inconsistent param types");
    }
    if (combinedNormalized.operator === zodiac_roles_deployments_1.Operator.Nor) {
        throw new Error("can not split sub-conditions of NOR");
    }
    if (!combinedNormalized.children) {
        throw new Error("no children to split on");
    }
    // Process children of ANDs
    // They need to be equal or splittable
    if (combinedNormalized.operator === zodiac_roles_deployments_1.Operator.And) {
        if (!combinedNormalized.children || !splitNormalized.children) {
            throw new Error("input conditions not normalized");
        }
        if (combinedNormalized.children.length !== splitNormalized.children.length) {
            throw new Error("inconsistent children");
        }
        // Combined and split conditions are both normalized, meaning children are ordered ny their condition ID.
        // They must differ in at most in one child, but this child will appear at different positions.
        const combinedChildrenIds = combinedNormalized.children.map((c) => c.$$id);
        const splitChildrenIds = splitNormalized.children.map((c) => c.$$id);
        const equalChildren = combinedNormalized.children.filter((_, i) => splitChildrenIds.includes(combinedChildrenIds[i]));
        if (equalChildren.length < combinedNormalized.children.length - 1) {
            throw new Error("more than one AND branch differs");
        }
        const combinedChildIndex = combinedChildrenIds.findIndex((id) => !splitChildrenIds.includes(id));
        const splitChildIndex = splitChildrenIds.findIndex((id) => !combinedChildrenIds.includes(id));
        const remainderChild = (0, exports.splitCondition)(combinedNormalized.children[combinedChildIndex], splitNormalized.children[splitChildIndex]);
        if (!remainderChild)
            throw new Error("invariant violation");
        return renormalize(Object.assign(Object.assign({}, combinedNormalized), { children: [...equalChildren, remainderChild] }));
    }
    // Process all children of matches and array conditions
    // They need to be equal or splittable
    let didSplit = false;
    const remainderChildren = combinedNormalized.children.map((child, index) => {
        const splitChild = splitNormalized.children && splitNormalized.children[index];
        if (!splitChild)
            throw new Error("inconsistent children");
        if (child.$$id === splitChild.$$id)
            return child;
        // Combined and split conditions are both normalized, meaning children will have the same order up to the first difference (i.e. the split child).
        if (didSplit) {
            throw new Error("more than one child differs");
        }
        const remainderChild = (0, exports.splitCondition)(child, splitChild);
        if (!remainderChild)
            throw new Error("invariant violation");
        didSplit = true;
        return remainderChild;
    });
    if (!didSplit) {
        // no child to split on, but different condition IDs. this should never happen
        throw new Error("invariant violation");
    }
    return renormalize(Object.assign(Object.assign({}, combinedNormalized), { children: remainderChildren }));
};
exports.splitCondition = splitCondition;
// When deriving an updated condition from a normalized condition, we need to re-normalize it.
// This is ensured by stripping out the now stale ID so normalizeCondition won't bail.
const renormalize = (condition) => (0, normalizeCondition_1.normalizeCondition)((0, normalizeCondition_1.stripIds)(condition));
