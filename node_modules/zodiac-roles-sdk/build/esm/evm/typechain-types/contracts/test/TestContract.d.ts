import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../../common";
export declare namespace TestContract {
    type DynamicTupleStruct = {
        a: BigNumberish;
        b: BytesLike;
    };
    type DynamicTupleStructOutput = [a: bigint, b: string] & {
        a: bigint;
        b: string;
    };
    type StaticTupleStruct = {
        a: BigNumberish;
        b: boolean;
    };
    type StaticTupleStructOutput = [a: bigint, b: boolean] & {
        a: bigint;
        b: boolean;
    };
    type DynamicNestedTupleStruct = {
        a: BigNumberish;
        b: TestContract.DynamicTupleStruct;
    };
    type DynamicNestedTupleStructOutput = [
        a: bigint,
        b: TestContract.DynamicTupleStructOutput
    ] & {
        a: bigint;
        b: TestContract.DynamicTupleStructOutput;
    };
    type StaticNestedTupleStruct = {
        a: BigNumberish;
        b: TestContract.StaticTupleStruct;
    };
    type StaticNestedTupleStructOutput = [
        a: bigint,
        b: TestContract.StaticTupleStructOutput
    ] & {
        a: bigint;
        b: TestContract.StaticTupleStructOutput;
    };
}
export interface TestContractInterface extends Interface {
    getFunction(nameOrSignature: "aStorageNumber" | "doEvenLess" | "doNothing" | "dynamic" | "dynamic32" | "dynamicDynamic32" | "dynamicString" | "emitTheSender" | "fnThatMaybeReverts" | "fnThatReverts" | "fnWithSingleParam" | "fnWithThreeParams" | "fnWithTwoMixedParams" | "fnWithTwoParams" | "mint" | "oneParamAddress" | "oneParamArrayOfDynamicTuple" | "oneParamArrayOfStatic" | "oneParamArrayOfStaticTuple" | "oneParamBytes" | "oneParamBytesSmall" | "oneParamBytesWord" | "oneParamDynamicNestedTuple" | "oneParamDynamicTuple" | "oneParamIntSmall" | "oneParamIntWord" | "oneParamStatic" | "oneParamStaticNestedTuple" | "oneParamStaticTuple" | "oneParamString" | "oneParamUintSmall" | "oneParamUintWord" | "receiveEthAndDoNothing" | "setAStorageNumber" | "spendAndMaybeRevert" | "testDynamic" | "twoParamsStatic" | "twoParamsStaticTupleStatic"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "DoEvenLess" | "DoNothing" | "Dynamic" | "Dynamic32" | "DynamicDynamic32" | "EmitTheSender" | "FnWithSingleParam" | "FnWithThreeParams" | "FnWithTwoMixedParams" | "FnWithTwoParams" | "Mint" | "Receive" | "ReceiveEthAndDoNothing" | "ReceiveFallback" | "TestDynamic"): EventFragment;
    encodeFunctionData(functionFragment: "aStorageNumber", values?: undefined): string;
    encodeFunctionData(functionFragment: "doEvenLess", values?: undefined): string;
    encodeFunctionData(functionFragment: "doNothing", values?: undefined): string;
    encodeFunctionData(functionFragment: "dynamic", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "dynamic32", values: [BytesLike[]]): string;
    encodeFunctionData(functionFragment: "dynamicDynamic32", values: [string, BytesLike[]]): string;
    encodeFunctionData(functionFragment: "dynamicString", values: [string]): string;
    encodeFunctionData(functionFragment: "emitTheSender", values?: undefined): string;
    encodeFunctionData(functionFragment: "fnThatMaybeReverts", values: [BigNumberish, boolean]): string;
    encodeFunctionData(functionFragment: "fnThatReverts", values?: undefined): string;
    encodeFunctionData(functionFragment: "fnWithSingleParam", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "fnWithThreeParams", values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "fnWithTwoMixedParams", values: [boolean, string]): string;
    encodeFunctionData(functionFragment: "fnWithTwoParams", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "mint", values: [AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "oneParamAddress", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "oneParamArrayOfDynamicTuple", values: [TestContract.DynamicTupleStruct[]]): string;
    encodeFunctionData(functionFragment: "oneParamArrayOfStatic", values: [BigNumberish[]]): string;
    encodeFunctionData(functionFragment: "oneParamArrayOfStaticTuple", values: [TestContract.StaticTupleStruct[]]): string;
    encodeFunctionData(functionFragment: "oneParamBytes", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "oneParamBytesSmall", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "oneParamBytesWord", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "oneParamDynamicNestedTuple", values: [TestContract.DynamicNestedTupleStruct]): string;
    encodeFunctionData(functionFragment: "oneParamDynamicTuple", values: [TestContract.DynamicTupleStruct]): string;
    encodeFunctionData(functionFragment: "oneParamIntSmall", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "oneParamIntWord", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "oneParamStatic", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "oneParamStaticNestedTuple", values: [TestContract.StaticNestedTupleStruct]): string;
    encodeFunctionData(functionFragment: "oneParamStaticTuple", values: [TestContract.StaticTupleStruct]): string;
    encodeFunctionData(functionFragment: "oneParamString", values: [string]): string;
    encodeFunctionData(functionFragment: "oneParamUintSmall", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "oneParamUintWord", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "receiveEthAndDoNothing", values?: undefined): string;
    encodeFunctionData(functionFragment: "setAStorageNumber", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "spendAndMaybeRevert", values: [BigNumberish, boolean]): string;
    encodeFunctionData(functionFragment: "testDynamic", values: [
        string,
        BigNumberish,
        string,
        boolean,
        BigNumberish,
        string,
        string
    ]): string;
    encodeFunctionData(functionFragment: "twoParamsStatic", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "twoParamsStaticTupleStatic", values: [TestContract.StaticTupleStruct, BigNumberish]): string;
    decodeFunctionResult(functionFragment: "aStorageNumber", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "doEvenLess", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "doNothing", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamic32", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicDynamic32", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dynamicString", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "emitTheSender", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fnThatMaybeReverts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fnThatReverts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fnWithSingleParam", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fnWithThreeParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fnWithTwoMixedParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fnWithTwoParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamArrayOfDynamicTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamArrayOfStatic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamArrayOfStaticTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamBytes", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamBytesSmall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamBytesWord", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamDynamicNestedTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamDynamicTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamIntSmall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamIntWord", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamStatic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamStaticNestedTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamStaticTuple", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamString", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamUintSmall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "oneParamUintWord", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "receiveEthAndDoNothing", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAStorageNumber", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "spendAndMaybeRevert", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "testDynamic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "twoParamsStatic", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "twoParamsStaticTupleStatic", data: BytesLike): Result;
}
export declare namespace DoEvenLessEvent {
    type InputTuple = [];
    type OutputTuple = [];
    interface OutputObject {
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace DoNothingEvent {
    type InputTuple = [];
    type OutputTuple = [];
    interface OutputObject {
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace DynamicEvent {
    type InputTuple = [arg0: BytesLike];
    type OutputTuple = [arg0: string];
    interface OutputObject {
        arg0: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace Dynamic32Event {
    type InputTuple = [arg0: BytesLike[]];
    type OutputTuple = [arg0: string[]];
    interface OutputObject {
        arg0: string[];
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace DynamicDynamic32Event {
    type InputTuple = [arg0: string, arg1: BytesLike[]];
    type OutputTuple = [arg0: string, arg1: string[]];
    interface OutputObject {
        arg0: string;
        arg1: string[];
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace EmitTheSenderEvent {
    type InputTuple = [arg0: AddressLike];
    type OutputTuple = [arg0: string];
    interface OutputObject {
        arg0: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace FnWithSingleParamEvent {
    type InputTuple = [arg0: BigNumberish];
    type OutputTuple = [arg0: bigint];
    interface OutputObject {
        arg0: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace FnWithThreeParamsEvent {
    type InputTuple = [
        arg0: BigNumberish,
        arg1: BigNumberish,
        arg2: BigNumberish
    ];
    type OutputTuple = [arg0: bigint, arg1: bigint, arg2: bigint];
    interface OutputObject {
        arg0: bigint;
        arg1: bigint;
        arg2: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace FnWithTwoMixedParamsEvent {
    type InputTuple = [arg0: boolean, arg1: string];
    type OutputTuple = [arg0: boolean, arg1: string];
    interface OutputObject {
        arg0: boolean;
        arg1: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace FnWithTwoParamsEvent {
    type InputTuple = [arg0: BigNumberish, arg1: BigNumberish];
    type OutputTuple = [arg0: bigint, arg1: bigint];
    interface OutputObject {
        arg0: bigint;
        arg1: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace MintEvent {
    type InputTuple = [to: AddressLike, amount: BigNumberish];
    type OutputTuple = [to: string, amount: bigint];
    interface OutputObject {
        to: string;
        amount: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace ReceiveEvent {
    type InputTuple = [];
    type OutputTuple = [];
    interface OutputObject {
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace ReceiveEthAndDoNothingEvent {
    type InputTuple = [amount: BigNumberish];
    type OutputTuple = [amount: bigint];
    interface OutputObject {
        amount: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace ReceiveFallbackEvent {
    type InputTuple = [amount: BigNumberish];
    type OutputTuple = [amount: bigint];
    interface OutputObject {
        amount: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TestDynamicEvent {
    type InputTuple = [
        test: string,
        test2: BigNumberish,
        test3: string,
        test4: boolean,
        test5: BigNumberish,
        test6: string,
        test7: string
    ];
    type OutputTuple = [
        test: string,
        test2: bigint,
        test3: string,
        test4: boolean,
        test5: bigint,
        test6: string,
        test7: string
    ];
    interface OutputObject {
        test: string;
        test2: bigint;
        test3: string;
        test4: boolean;
        test5: bigint;
        test6: string;
        test7: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface TestContract extends BaseContract {
    connect(runner?: ContractRunner | null): TestContract;
    waitForDeployment(): Promise<this>;
    interface: TestContractInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    aStorageNumber: TypedContractMethod<[], [bigint], "view">;
    doEvenLess: TypedContractMethod<[], [void], "nonpayable">;
    doNothing: TypedContractMethod<[], [void], "nonpayable">;
    dynamic: TypedContractMethod<[first: BytesLike], [void], "nonpayable">;
    dynamic32: TypedContractMethod<[first: BytesLike[]], [void], "nonpayable">;
    dynamicDynamic32: TypedContractMethod<[
        first: string,
        second: BytesLike[]
    ], [
        void
    ], "nonpayable">;
    dynamicString: TypedContractMethod<[arg0: string], [void], "nonpayable">;
    emitTheSender: TypedContractMethod<[], [void], "nonpayable">;
    fnThatMaybeReverts: TypedContractMethod<[
        a: BigNumberish,
        maybe: boolean
    ], [
        bigint
    ], "view">;
    fnThatReverts: TypedContractMethod<[], [void], "view">;
    fnWithSingleParam: TypedContractMethod<[p: BigNumberish], [void], "payable">;
    fnWithThreeParams: TypedContractMethod<[
        a: BigNumberish,
        b: BigNumberish,
        c: BigNumberish
    ], [
        void
    ], "nonpayable">;
    fnWithTwoMixedParams: TypedContractMethod<[
        a: boolean,
        s: string
    ], [
        void
    ], "nonpayable">;
    fnWithTwoParams: TypedContractMethod<[
        a: BigNumberish,
        b: BigNumberish
    ], [
        void
    ], "nonpayable">;
    mint: TypedContractMethod<[
        to: AddressLike,
        amount: BigNumberish
    ], [
        bigint
    ], "nonpayable">;
    oneParamAddress: TypedContractMethod<[
        arg0: AddressLike
    ], [
        void
    ], "nonpayable">;
    oneParamArrayOfDynamicTuple: TypedContractMethod<[
        arg0: TestContract.DynamicTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    oneParamArrayOfStatic: TypedContractMethod<[
        arg0: BigNumberish[]
    ], [
        void
    ], "nonpayable">;
    oneParamArrayOfStaticTuple: TypedContractMethod<[
        arg0: TestContract.StaticTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    oneParamBytes: TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    oneParamBytesSmall: TypedContractMethod<[
        arg0: BytesLike
    ], [
        void
    ], "nonpayable">;
    oneParamBytesWord: TypedContractMethod<[
        arg0: BytesLike
    ], [
        void
    ], "nonpayable">;
    oneParamDynamicNestedTuple: TypedContractMethod<[
        arg0: TestContract.DynamicNestedTupleStruct
    ], [
        void
    ], "nonpayable">;
    oneParamDynamicTuple: TypedContractMethod<[
        arg0: TestContract.DynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    oneParamIntSmall: TypedContractMethod<[
        arg0: BigNumberish
    ], [
        void
    ], "nonpayable">;
    oneParamIntWord: TypedContractMethod<[
        arg0: BigNumberish
    ], [
        void
    ], "nonpayable">;
    oneParamStatic: TypedContractMethod<[arg0: BigNumberish], [void], "payable">;
    oneParamStaticNestedTuple: TypedContractMethod<[
        arg0: TestContract.StaticNestedTupleStruct
    ], [
        void
    ], "nonpayable">;
    oneParamStaticTuple: TypedContractMethod<[
        arg0: TestContract.StaticTupleStruct
    ], [
        void
    ], "nonpayable">;
    oneParamString: TypedContractMethod<[arg0: string], [void], "nonpayable">;
    oneParamUintSmall: TypedContractMethod<[
        arg0: BigNumberish
    ], [
        void
    ], "nonpayable">;
    oneParamUintWord: TypedContractMethod<[
        arg0: BigNumberish
    ], [
        void
    ], "nonpayable">;
    receiveEthAndDoNothing: TypedContractMethod<[], [void], "payable">;
    setAStorageNumber: TypedContractMethod<[
        value: BigNumberish
    ], [
        void
    ], "nonpayable">;
    spendAndMaybeRevert: TypedContractMethod<[
        arg0: BigNumberish,
        revert_: boolean
    ], [
        void
    ], "view">;
    testDynamic: TypedContractMethod<[
        test: string,
        test2: BigNumberish,
        test3: string,
        test4: boolean,
        test5: BigNumberish,
        test6: string,
        test7: string
    ], [
        boolean
    ], "nonpayable">;
    twoParamsStatic: TypedContractMethod<[
        a: BigNumberish,
        b: BigNumberish
    ], [
        void
    ], "nonpayable">;
    twoParamsStaticTupleStatic: TypedContractMethod<[
        arg0: TestContract.StaticTupleStruct,
        arg1: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "aStorageNumber"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "doEvenLess"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "doNothing"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "dynamic"): TypedContractMethod<[first: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "dynamic32"): TypedContractMethod<[first: BytesLike[]], [void], "nonpayable">;
    getFunction(nameOrSignature: "dynamicDynamic32"): TypedContractMethod<[
        first: string,
        second: BytesLike[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "dynamicString"): TypedContractMethod<[arg0: string], [void], "nonpayable">;
    getFunction(nameOrSignature: "emitTheSender"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "fnThatMaybeReverts"): TypedContractMethod<[a: BigNumberish, maybe: boolean], [bigint], "view">;
    getFunction(nameOrSignature: "fnThatReverts"): TypedContractMethod<[], [void], "view">;
    getFunction(nameOrSignature: "fnWithSingleParam"): TypedContractMethod<[p: BigNumberish], [void], "payable">;
    getFunction(nameOrSignature: "fnWithThreeParams"): TypedContractMethod<[
        a: BigNumberish,
        b: BigNumberish,
        c: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "fnWithTwoMixedParams"): TypedContractMethod<[a: boolean, s: string], [void], "nonpayable">;
    getFunction(nameOrSignature: "fnWithTwoParams"): TypedContractMethod<[
        a: BigNumberish,
        b: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "mint"): TypedContractMethod<[
        to: AddressLike,
        amount: BigNumberish
    ], [
        bigint
    ], "nonpayable">;
    getFunction(nameOrSignature: "oneParamAddress"): TypedContractMethod<[arg0: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamArrayOfDynamicTuple"): TypedContractMethod<[
        arg0: TestContract.DynamicTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "oneParamArrayOfStatic"): TypedContractMethod<[arg0: BigNumberish[]], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamArrayOfStaticTuple"): TypedContractMethod<[
        arg0: TestContract.StaticTupleStruct[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "oneParamBytes"): TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamBytesSmall"): TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamBytesWord"): TypedContractMethod<[arg0: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamDynamicNestedTuple"): TypedContractMethod<[
        arg0: TestContract.DynamicNestedTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "oneParamDynamicTuple"): TypedContractMethod<[
        arg0: TestContract.DynamicTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "oneParamIntSmall"): TypedContractMethod<[arg0: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamIntWord"): TypedContractMethod<[arg0: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamStatic"): TypedContractMethod<[arg0: BigNumberish], [void], "payable">;
    getFunction(nameOrSignature: "oneParamStaticNestedTuple"): TypedContractMethod<[
        arg0: TestContract.StaticNestedTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "oneParamStaticTuple"): TypedContractMethod<[
        arg0: TestContract.StaticTupleStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "oneParamString"): TypedContractMethod<[arg0: string], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamUintSmall"): TypedContractMethod<[arg0: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "oneParamUintWord"): TypedContractMethod<[arg0: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "receiveEthAndDoNothing"): TypedContractMethod<[], [void], "payable">;
    getFunction(nameOrSignature: "setAStorageNumber"): TypedContractMethod<[value: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "spendAndMaybeRevert"): TypedContractMethod<[
        arg0: BigNumberish,
        revert_: boolean
    ], [
        void
    ], "view">;
    getFunction(nameOrSignature: "testDynamic"): TypedContractMethod<[
        test: string,
        test2: BigNumberish,
        test3: string,
        test4: boolean,
        test5: BigNumberish,
        test6: string,
        test7: string
    ], [
        boolean
    ], "nonpayable">;
    getFunction(nameOrSignature: "twoParamsStatic"): TypedContractMethod<[
        a: BigNumberish,
        b: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "twoParamsStaticTupleStatic"): TypedContractMethod<[
        arg0: TestContract.StaticTupleStruct,
        arg1: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getEvent(key: "DoEvenLess"): TypedContractEvent<DoEvenLessEvent.InputTuple, DoEvenLessEvent.OutputTuple, DoEvenLessEvent.OutputObject>;
    getEvent(key: "DoNothing"): TypedContractEvent<DoNothingEvent.InputTuple, DoNothingEvent.OutputTuple, DoNothingEvent.OutputObject>;
    getEvent(key: "Dynamic"): TypedContractEvent<DynamicEvent.InputTuple, DynamicEvent.OutputTuple, DynamicEvent.OutputObject>;
    getEvent(key: "Dynamic32"): TypedContractEvent<Dynamic32Event.InputTuple, Dynamic32Event.OutputTuple, Dynamic32Event.OutputObject>;
    getEvent(key: "DynamicDynamic32"): TypedContractEvent<DynamicDynamic32Event.InputTuple, DynamicDynamic32Event.OutputTuple, DynamicDynamic32Event.OutputObject>;
    getEvent(key: "EmitTheSender"): TypedContractEvent<EmitTheSenderEvent.InputTuple, EmitTheSenderEvent.OutputTuple, EmitTheSenderEvent.OutputObject>;
    getEvent(key: "FnWithSingleParam"): TypedContractEvent<FnWithSingleParamEvent.InputTuple, FnWithSingleParamEvent.OutputTuple, FnWithSingleParamEvent.OutputObject>;
    getEvent(key: "FnWithThreeParams"): TypedContractEvent<FnWithThreeParamsEvent.InputTuple, FnWithThreeParamsEvent.OutputTuple, FnWithThreeParamsEvent.OutputObject>;
    getEvent(key: "FnWithTwoMixedParams"): TypedContractEvent<FnWithTwoMixedParamsEvent.InputTuple, FnWithTwoMixedParamsEvent.OutputTuple, FnWithTwoMixedParamsEvent.OutputObject>;
    getEvent(key: "FnWithTwoParams"): TypedContractEvent<FnWithTwoParamsEvent.InputTuple, FnWithTwoParamsEvent.OutputTuple, FnWithTwoParamsEvent.OutputObject>;
    getEvent(key: "Mint"): TypedContractEvent<MintEvent.InputTuple, MintEvent.OutputTuple, MintEvent.OutputObject>;
    getEvent(key: "Receive"): TypedContractEvent<ReceiveEvent.InputTuple, ReceiveEvent.OutputTuple, ReceiveEvent.OutputObject>;
    getEvent(key: "ReceiveEthAndDoNothing"): TypedContractEvent<ReceiveEthAndDoNothingEvent.InputTuple, ReceiveEthAndDoNothingEvent.OutputTuple, ReceiveEthAndDoNothingEvent.OutputObject>;
    getEvent(key: "ReceiveFallback"): TypedContractEvent<ReceiveFallbackEvent.InputTuple, ReceiveFallbackEvent.OutputTuple, ReceiveFallbackEvent.OutputObject>;
    getEvent(key: "TestDynamic"): TypedContractEvent<TestDynamicEvent.InputTuple, TestDynamicEvent.OutputTuple, TestDynamicEvent.OutputObject>;
    filters: {
        "DoEvenLess()": TypedContractEvent<DoEvenLessEvent.InputTuple, DoEvenLessEvent.OutputTuple, DoEvenLessEvent.OutputObject>;
        DoEvenLess: TypedContractEvent<DoEvenLessEvent.InputTuple, DoEvenLessEvent.OutputTuple, DoEvenLessEvent.OutputObject>;
        "DoNothing()": TypedContractEvent<DoNothingEvent.InputTuple, DoNothingEvent.OutputTuple, DoNothingEvent.OutputObject>;
        DoNothing: TypedContractEvent<DoNothingEvent.InputTuple, DoNothingEvent.OutputTuple, DoNothingEvent.OutputObject>;
        "Dynamic(bytes)": TypedContractEvent<DynamicEvent.InputTuple, DynamicEvent.OutputTuple, DynamicEvent.OutputObject>;
        Dynamic: TypedContractEvent<DynamicEvent.InputTuple, DynamicEvent.OutputTuple, DynamicEvent.OutputObject>;
        "Dynamic32(bytes4[])": TypedContractEvent<Dynamic32Event.InputTuple, Dynamic32Event.OutputTuple, Dynamic32Event.OutputObject>;
        Dynamic32: TypedContractEvent<Dynamic32Event.InputTuple, Dynamic32Event.OutputTuple, Dynamic32Event.OutputObject>;
        "DynamicDynamic32(string,bytes2[])": TypedContractEvent<DynamicDynamic32Event.InputTuple, DynamicDynamic32Event.OutputTuple, DynamicDynamic32Event.OutputObject>;
        DynamicDynamic32: TypedContractEvent<DynamicDynamic32Event.InputTuple, DynamicDynamic32Event.OutputTuple, DynamicDynamic32Event.OutputObject>;
        "EmitTheSender(address)": TypedContractEvent<EmitTheSenderEvent.InputTuple, EmitTheSenderEvent.OutputTuple, EmitTheSenderEvent.OutputObject>;
        EmitTheSender: TypedContractEvent<EmitTheSenderEvent.InputTuple, EmitTheSenderEvent.OutputTuple, EmitTheSenderEvent.OutputObject>;
        "FnWithSingleParam(uint256)": TypedContractEvent<FnWithSingleParamEvent.InputTuple, FnWithSingleParamEvent.OutputTuple, FnWithSingleParamEvent.OutputObject>;
        FnWithSingleParam: TypedContractEvent<FnWithSingleParamEvent.InputTuple, FnWithSingleParamEvent.OutputTuple, FnWithSingleParamEvent.OutputObject>;
        "FnWithThreeParams(uint256,uint256,uint256)": TypedContractEvent<FnWithThreeParamsEvent.InputTuple, FnWithThreeParamsEvent.OutputTuple, FnWithThreeParamsEvent.OutputObject>;
        FnWithThreeParams: TypedContractEvent<FnWithThreeParamsEvent.InputTuple, FnWithThreeParamsEvent.OutputTuple, FnWithThreeParamsEvent.OutputObject>;
        "FnWithTwoMixedParams(bool,string)": TypedContractEvent<FnWithTwoMixedParamsEvent.InputTuple, FnWithTwoMixedParamsEvent.OutputTuple, FnWithTwoMixedParamsEvent.OutputObject>;
        FnWithTwoMixedParams: TypedContractEvent<FnWithTwoMixedParamsEvent.InputTuple, FnWithTwoMixedParamsEvent.OutputTuple, FnWithTwoMixedParamsEvent.OutputObject>;
        "FnWithTwoParams(uint256,uint256)": TypedContractEvent<FnWithTwoParamsEvent.InputTuple, FnWithTwoParamsEvent.OutputTuple, FnWithTwoParamsEvent.OutputObject>;
        FnWithTwoParams: TypedContractEvent<FnWithTwoParamsEvent.InputTuple, FnWithTwoParamsEvent.OutputTuple, FnWithTwoParamsEvent.OutputObject>;
        "Mint(address,uint256)": TypedContractEvent<MintEvent.InputTuple, MintEvent.OutputTuple, MintEvent.OutputObject>;
        Mint: TypedContractEvent<MintEvent.InputTuple, MintEvent.OutputTuple, MintEvent.OutputObject>;
        "Receive()": TypedContractEvent<ReceiveEvent.InputTuple, ReceiveEvent.OutputTuple, ReceiveEvent.OutputObject>;
        Receive: TypedContractEvent<ReceiveEvent.InputTuple, ReceiveEvent.OutputTuple, ReceiveEvent.OutputObject>;
        "ReceiveEthAndDoNothing(uint256)": TypedContractEvent<ReceiveEthAndDoNothingEvent.InputTuple, ReceiveEthAndDoNothingEvent.OutputTuple, ReceiveEthAndDoNothingEvent.OutputObject>;
        ReceiveEthAndDoNothing: TypedContractEvent<ReceiveEthAndDoNothingEvent.InputTuple, ReceiveEthAndDoNothingEvent.OutputTuple, ReceiveEthAndDoNothingEvent.OutputObject>;
        "ReceiveFallback(uint256)": TypedContractEvent<ReceiveFallbackEvent.InputTuple, ReceiveFallbackEvent.OutputTuple, ReceiveFallbackEvent.OutputObject>;
        ReceiveFallback: TypedContractEvent<ReceiveFallbackEvent.InputTuple, ReceiveFallbackEvent.OutputTuple, ReceiveFallbackEvent.OutputObject>;
        "TestDynamic(string,uint256,string,bool,uint8,string,string)": TypedContractEvent<TestDynamicEvent.InputTuple, TestDynamicEvent.OutputTuple, TestDynamicEvent.OutputObject>;
        TestDynamic: TypedContractEvent<TestDynamicEvent.InputTuple, TestDynamicEvent.OutputTuple, TestDynamicEvent.OutputObject>;
    };
}
