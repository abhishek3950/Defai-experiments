import * as ethSdk from "@gnosis-guild/eth-sdk-client";
import { BaseContract, ContractTransaction, ContractTransactionResponse, FunctionFragment, TransactionRequest } from "ethers";
import { TupleScopings } from "../permissions/authoring/conditions/types";
import { TargetPermission, FunctionPermission } from "../permissions/types";
type PickByValue<T, Value> = {
    [P in keyof T as T[P] extends Value ? P extends string ? P : never : never]: T[P];
};
type Options = {
    /** Allow sending an Ether value */
    send?: boolean;
    /** Allow making delegate calls */
    delegatecall?: boolean;
    /** Restrict the total Ether value sent using the specified allowance */
    etherWithinAllowance?: `0x${string}`;
    /** Restrict the call rate using the specified allowance */
    callWithinAllowance?: `0x${string}`;
};
/** We need to skip over functions with "view" state mutability. We do this by matching the ethers ContractMethod type  */
interface StateMutatingContractMethod {
    (): Promise<ContractTransactionResponse>;
    name: string;
    fragment: FunctionFragment;
    getFragment(): FunctionFragment;
    populateTransaction(): Promise<ContractTransaction>;
    staticCall(): Promise<any>;
    send(): Promise<ContractTransactionResponse>;
    estimateGas(): Promise<bigint>;
    staticCallResult(): Promise<any>;
}
type StateMutatingContractMethods<C extends BaseContract> = PickByValue<C, StateMutatingContractMethod>;
type BaseOverrides = Omit<TransactionRequest, "to" | "data">;
type NonPayableOverrides = Omit<BaseOverrides, "value" | "blockTag" | "enableCcipRead">;
type PayableOverrides = Omit<BaseOverrides, "blockTag" | "enableCcipRead">;
type AllowFunctionParameters<MethodArgs extends [...any]> = MethodArgs extends [
    ...any,
    NonPayableOverrides | PayableOverrides
] ? never : [...TupleScopings<MethodArgs>, options?: Options];
type AllowFunctions<C extends BaseContract> = {
    [key in keyof StateMutatingContractMethods<C>]: (...args: AllowFunctionParameters<Parameters<C[key] extends (...args: any) => any ? C[key] : never>>) => FunctionPermission;
};
type AllowContract<C extends BaseContract> = {
    [EVERYTHING]: (options?: Options) => TargetPermission;
} & AllowFunctions<C>;
export declare const EVERYTHING: unique symbol;
type EthSdk = {
    [key: string]: EthSdk | BaseContract;
};
type AllowKit<S extends EthSdk> = {
    [Key in keyof S]: S[Key] extends BaseContract ? AllowContract<S[Key]> : S[Key] extends EthSdk ? AllowKit<S[Key]> : never;
};
type SdkGetterName = Exclude<keyof typeof ethSdk, "getContract">;
type NetworkName<S extends SdkGetterName> = S extends `get${infer N}Sdk` ? Uncapitalize<N> : never;
type AllowKitMap = {
    [Key in NetworkName<SdkGetterName>]: AllowKit<ReturnType<(typeof ethSdk)[`get${Capitalize<Key>}Sdk`]>>;
};
export declare const allow: AllowKitMap;
export {};
