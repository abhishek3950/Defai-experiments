import * as ethSdk from "@gnosis-guild/eth-sdk-client";
import { BaseContract, ethers, isError, } from "ethers";
import { Operator, ParameterType } from "zodiac-roles-deployments";
// We import via alias to avoid double bundling of sdk functions
// eslint does not know about our Typescript path alias
// eslint-disable-next-line import/no-unresolved
import { c } from "zodiac-roles-sdk";
// For things that are not publicly exported we still use relative paths.
// Since these are mainly types, this won't blow up bundles.
import { callWithinAllowance, etherWithinAllowance, } from "../permissions/authoring/conditions/allowances";
import { coercePermission } from "../permissions/utils";
const makeAllowFunction = (contract, name) => {
    const functionFragment = contract.interface.getFunction(name);
    const functionInputs = functionFragment.inputs;
    if (typeof contract.target !== "string" ||
        !contract.target.startsWith("0x")) {
        throw new Error("Only addresses as contract targets are supported");
    }
    return (...args) => {
        const scopings = args.slice(0, functionInputs.length);
        const hasScopings = scopings.some((s) => !!s);
        const options = (args[functionInputs.length] || {});
        const presetFunction = {
            targetAddress: contract.target,
            signature: functionFragment.format("sighash"),
            condition: hasScopings
                ? c.calldataMatches(scopings, functionInputs)()
                : undefined,
        };
        return applyOptions(coercePermission(presetFunction), options);
    };
};
const emptyCalldataMatches = {
    paramType: ParameterType.Calldata,
    operator: Operator.Matches,
    children: [],
};
/**
 * EthersWithinAllowance and CallWithinAllowance are global conditions that restrict the total Ether value sent or the call rate.
 * They must be appended as children of the root calldata matches node.
 */
const applyGlobalAllowance = (condition = emptyCalldataMatches, allowanceCondition) => {
    if (condition.paramType !== ParameterType.Calldata ||
        condition.operator !== Operator.Matches) {
        throw new Error("Global allowance can only be applied to calldata matches nodes");
    }
    return {
        ...condition,
        children: [...(condition.children || []), allowanceCondition],
    };
};
const applyOptions = (entry, options) => {
    let condition = entry.condition;
    if (options.etherWithinAllowance) {
        if (!options.send) {
            throw new Error("`etherWithinAllowance` can only be used if `send` is allowed");
        }
        condition = applyGlobalAllowance(condition, etherWithinAllowance(options.etherWithinAllowance)());
    }
    if (options.callWithinAllowance) {
        condition = applyGlobalAllowance(condition, callWithinAllowance(options.callWithinAllowance)());
    }
    return {
        ...entry,
        send: options.send,
        delegatecall: options.delegatecall,
        condition,
    };
};
export const EVERYTHING = Symbol("EVERYTHING");
const makeAllowContract = (contract) => {
    const allowEverything = (options) => {
        return {
            targetAddress: contract.target,
            ...options,
        };
    };
    // TODO use Proxy just like ethers v6
    // https://github.com/ethers-io/ethers.js/blob/main/src.ts/contract/contract.ts#L777
    const contractHasFunction = (prop) => {
        try {
            contract.getFunction(prop);
        }
        catch (error) {
            if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                throw error;
            }
            return false;
        }
        return true;
    };
    return new Proxy({}, {
        get: (target, prop) => {
            if (prop === EVERYTHING) {
                return allowEverything;
            }
            if (typeof prop !== "string") {
                return undefined;
            }
            if (contractHasFunction(prop)) {
                return makeAllowFunction(contract, prop);
            }
            return undefined;
        },
        has: (target, prop) => {
            if (typeof prop === "symbol") {
                return prop === EVERYTHING;
            }
            return contractHasFunction(prop);
        },
    });
};
const mapSdk = (sdk) => {
    return Object.keys(sdk).reduce((acc, key) => {
        // for this check to work reliably, make sure ethers node_modules is not duplicated
        if (sdk[key] instanceof BaseContract) {
            acc[key] = makeAllowContract(sdk[key]);
        }
        else {
            acc[key] = mapSdk(sdk[key]);
        }
        return acc;
    }, {});
};
const uncapitalize = (s) => s.charAt(0).toLowerCase() + s.slice(1);
export const allow = Object.keys(ethSdk).reduce((acc, sdkGetterName) => {
    if (sdkGetterName === "getContract")
        return acc;
    const network = uncapitalize(sdkGetterName.slice(3, -3));
    acc[network] = mapSdk(
    // eslint-disable-next-line import/namespace
    ethSdk[sdkGetterName](ethers.getDefaultProvider()));
    return acc;
}, {});
