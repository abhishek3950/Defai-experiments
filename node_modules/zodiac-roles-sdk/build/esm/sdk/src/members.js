import { getAddress } from "ethers";
import { fetchRole } from "zodiac-roles-deployments";
import { Roles__factory } from "../../evm/typechain-types";
const rolesInterface = Roles__factory.createInterface();
/**
 * Returns a set of encoded call data to be sent to the Roles mod for updating the members of the given role.
 *
 * @param roleKey The key of the role
 * @param members Array of member addresses
 */
export const applyMembers = async (roleKey, members, options) => {
    let currentMembers;
    if ("currentMembers" in options && options.currentMembers) {
        currentMembers = options.currentMembers;
    }
    else {
        if ("chainId" in options && options.chainId) {
            const role = await fetchRole({
                chainId: options.chainId,
                address: options.address,
                roleKey,
            });
            if (!role) {
                throw new Error(`Role ${roleKey} not found on chain ${options.chainId}`);
            }
            currentMembers = role.members;
        }
        else {
            throw new Error("Either `currentMembers` or `chainId` and `address` must be specified");
        }
    }
    const currentSet = new Set(currentMembers.map((member) => getAddress(member)));
    const membersSet = new Set(members.map((member) => getAddress(member)));
    let assignments;
    switch (options.mode) {
        case "replace":
            assignments = replaceMembers(currentSet, membersSet);
            break;
        case "extend":
            assignments = extendMembers(currentSet, membersSet);
            break;
        case "remove":
            assignments = removeMembers(currentSet, membersSet);
            break;
        default:
            throw new Error(`Invalid mode: ${options.mode}`);
    }
    if (options.log) {
        const log = options.log === true ? console.log : options.log;
        assignments.remove.forEach((account) => log(`ðŸ‘¤ Remove member ${account}`));
        assignments.add.forEach((account) => log(`ðŸ‘¤ Add member ${account}`));
    }
    return [
        ...assignments.remove.map((member) => encodeRemoveCall(roleKey, member)),
        ...assignments.add.map((member) => encodeAddCall(roleKey, member)),
    ];
};
const replaceMembers = (current, next) => ({
    remove: [...current].filter((member) => !next.has(member)),
    add: [...next].filter((member) => !current.has(member)),
});
const extendMembers = (current, add) => ({
    remove: [],
    add: [...add].filter((member) => !current.has(member)),
});
const removeMembers = (current, remove) => ({
    remove: [...remove].filter((member) => current.has(member)),
    add: [],
});
const encodeAddCall = (roleKey, member) => {
    return rolesInterface.encodeFunctionData("assignRoles", [
        member,
        [roleKey],
        [true],
    ]);
};
const encodeRemoveCall = (roleKey, member) => {
    return rolesInterface.encodeFunctionData("assignRoles", [
        member,
        [roleKey],
        [false],
    ]);
};
