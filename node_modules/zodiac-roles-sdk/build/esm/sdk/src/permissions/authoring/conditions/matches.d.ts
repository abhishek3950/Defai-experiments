import { ParamType } from "ethers";
import { Condition, Operator, ParameterType } from "zodiac-roles-deployments";
import { AbiType, FunctionPermission } from "../../types";
import { Scoping, StructScoping, TupleScopings } from "./types";
/**
 * Matches a tuple or array against a structure of conditions.
 *
 * Throws if the type is not a tuple or array. Throws if the structure of conditions is incompatible with the type.
 * @param scoping The conditions on the tuple or array elements
 */
export declare const matches: <S extends TupleScopings<any> | StructScoping<any>>(scoping: S) => (abiType: ParamType) => Condition;
type CalldataMatches = {
    /**
     * Matches the parameters part of EVM call data against a structure of conditions.
     *
     * Skips over the first 4 bytes (function selector) and matches the ABI encoded parameters against the structure of conditions.
     * Optionally, also checks the function selector.
     *
     * @param scoping The conditions structure over the decoded parameters
     * @param abiTypes The parameter types defining how to decode bytes
     * @param selector If set, checks that the 4 bytes function selector matches the given value
     **/
    <S extends TupleScopings<any>>(scopings: S, abiTypes: readonly AbiType[], selector?: `0x${string}`): (abiType?: ParamType) => Condition;
    /**
     * Matches EVM call data against a reference function permission.
     *
     * The 4 bytes function selector is checked against the function permission selector.
     * Also, function permission condition is evaluated on the call data.
     *
     * @param functionPermission The reference function permission
     **/
    (functionPermission: FunctionPermission): (abiType?: ParamType) => Condition;
};
export declare const calldataMatches: CalldataMatches;
/**
 * Matches standard ABI encoded bytes against a structure of conditions.
 *
 * @param scoping The conditions structure over the decoded parameters
 * @param abiTypes The parameter types defining how to decode bytes
 **/
export declare const abiEncodedMatches: <S extends TupleScopings<any>>(scopings: S, abiTypes: AbiType[]) => (abiType?: ParamType) => {
    paramType: ParameterType;
    operator: Operator;
    children: Condition[];
};
/**
 * Maps a scoping (shortcut notation or condition function) to a condition.
 * @param scoping The scoping to map.
 * @param abiType The abi type of the parameter the scoping applies to.
 * @returns
 */
export declare function mapScoping(scoping: Scoping<any> | undefined, abiType: ParamType): Condition | undefined;
export {};
