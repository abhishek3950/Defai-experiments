import { fetchRole } from "zodiac-roles-deployments";
import { encodeCalls, grant, logCall, removeObsoleteCalls, revoke, } from "../calls";
import { checkIntegrity } from "./checkIntegrity";
import { diffTargets } from "./diffTargets";
/**
 * Returns a set of encoded call data to be sent to the Roles mod for updating the targets of the given role.
 *
 * @param roleKey The key of the role to update
 * @param targets Targets to apply to the role
 * @param options Options for the update
 */
export const applyTargets = async (roleKey, targets, options) => {
    let currentTargets;
    if ("currentTargets" in options && options.currentTargets) {
        currentTargets = options.currentTargets;
    }
    else {
        if ("chainId" in options && options.chainId) {
            const role = await fetchRole({
                chainId: options.chainId,
                address: options.address,
                roleKey,
            });
            if (!role) {
                throw new Error(`Role ${roleKey} not found on chain ${options.chainId}`);
            }
            currentTargets = role.targets;
        }
        else {
            throw new Error("Either `currentTargets` or `chainId` and `address` must be specified");
        }
    }
    checkIntegrity(targets);
    let calls;
    switch (options.mode) {
        case "replace":
            calls = replaceTargets(currentTargets, targets);
            break;
        case "extend":
            calls = extendTargets(currentTargets, targets);
            break;
        case "remove":
            calls = removeTargets(currentTargets, targets);
            break;
        default:
            throw new Error(`Invalid mode: ${options.mode}`);
    }
    if (options.log) {
        calls.forEach((call) => logCall(call, options.log === true ? console.log : options.log || undefined));
    }
    return encodeCalls(roleKey, calls);
};
const extendTargets = (current, add) => {
    // TODO if current grants a fully-cleared target, we need to remove function-scoped permissions to that target from add
    // TODO merge permissions to same target+function by joining their conditions with OR
    return grant(diffTargets(add, current));
};
/**
 * Computes the set of calls to update the current targets of a role to no longer include the targets passed for `subtract`.
 * @param current targets of the role that shall be updated
 * @param subtract targets to subtract from the current targets of the role
 * @returns The set of calls to make to the Roles modifier owning the role
 */
const removeTargets = (current, subtract) => {
    const notGranted = diffTargets(subtract, current);
    const toRevoke = diffTargets(subtract, notGranted);
    // TODO throw, if subtract contains a function to a target that is fully-cleared in current
    return revoke(toRevoke);
};
/**
 * Computes the set of calls to update the targets of a role
 * @param current targets of the role that shall be updated
 * @param next targets of the role describing the desired target state
 * @returns The set of calls to make to the Roles modifier owning the role
 */
export const replaceTargets = (current, next) => {
    return removeObsoleteCalls([
        ...revoke(diffTargets(current, next)),
        ...grant(diffTargets(next, current)),
    ]);
};
