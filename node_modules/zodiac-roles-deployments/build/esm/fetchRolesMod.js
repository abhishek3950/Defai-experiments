import { chains } from "./chains";
import { Clearance, ExecutionOptions, } from "./types";
const QUERY = `
  query RolesMod($id: String) {
    rolesModifier(id: $id) {
      address
      owner
      avatar
      target 
      roles(first: 1000) {
        key
        members(first: 1000) {
          member {
            address
          }
        }
        targets(first: 1000) {
          address
          clearance
          executionOptions
          functions(first: 1000) {
            selector
            wildcarded
            executionOptions
          }
        }
        lastUpdate
      }
      allowances(first: 1000) {
        key
        refill
        maxRefill
        period
        balance
        timestamp
      }
      unwrapAdapters(
        where: {
          selector: "0x8d80ff0a", 
          adapterAddress: "0x93b7fcbc63ed8a3a24b59e1c3e6649d50b7427c0"
        }
      ) {
        targetAddress
      }
    }
  }
`;
export const fetchRolesMod = async ({ address, ...rest }, options) => {
    const endpoint = "subgraph" in rest ? rest.subgraph : chains[rest.chainId].subgraph;
    const res = await fetch(endpoint, {
        ...options,
        method: "POST",
        headers: {
            ...options?.headers,
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            query: QUERY,
            variables: { id: address.toLowerCase() },
            operationName: "RolesMod",
        }),
    });
    const { data, error, errors } = await res.json();
    if (error || (errors && errors[0])) {
        throw new Error(error || errors[0]);
    }
    if (!data || !data.rolesModifier) {
        return null;
    }
    assertNoPagination(data.rolesModifier.roles);
    for (const role of data.rolesModifier.roles) {
        assertNoPagination(role.members);
        assertNoPagination(role.targets);
    }
    return mapGraphQl(data.rolesModifier);
};
const mapGraphQl = (rolesModifier) => ({
    ...rolesModifier,
    roles: rolesModifier.roles.map(mapGraphQlRole),
    allowances: rolesModifier.allowances.map((allowance) => ({
        key: allowance.key,
        refill: BigInt(allowance.refill),
        maxRefill: BigInt(allowance.maxRefill),
        period: BigInt(allowance.period),
        balance: BigInt(allowance.balance),
        timestamp: BigInt(allowance.timestamp),
    })),
    multiSendAddresses: rolesModifier.unwrapAdapters.map((adapter) => adapter.targetAddress),
});
const mapGraphQlRole = (role) => ({
    key: role.key,
    members: role.members.map((assignment) => assignment.member.address),
    targets: role.targets
        .filter((t) => t.clearance !== "None" &&
        !(t.clearance === "Function" && t.functions.length === 0))
        .map((target) => ({
        address: target.address,
        clearance: Clearance[target.clearance],
        executionOptions: ExecutionOptions[target.executionOptions],
        functions: target.functions.map((func) => ({
            selector: func.selector,
            executionOptions: ExecutionOptions[func.executionOptions],
            wildcarded: func.wildcarded,
        })),
    })),
});
const assertNoPagination = (data) => {
    if (data.length === 1000) {
        throw new Error("Pagination not supported");
    }
};
