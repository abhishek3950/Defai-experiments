import { chains } from "./chains";
import { Clearance, ExecutionOptions, } from "./types";
const ROLE_QUERY = `
query Role($id: String) {
  role(id: $id) {
    key
    members(first: 1000) {
      member {
        address
      }
    }
    targets(first: 1000) {
      address
      clearance
      executionOptions
      functions(first: 1000) {
        selector
        executionOptions
        wildcarded
        condition {
          id
          json
        }
      }
    }
    annotations(first: 1000) {
      uri
      schema
    }
    lastUpdate
  }
}
`.trim();
const ROLE_AT_BLOCK_QUERY = `
query Role($id: String, $block: Int) {
  role(id: $id, block: { number: $block }) {
    key
    members(first: 1000) {
      member {
        address
      }
    }
    targets(first: 1000) {
      address
      clearance
      executionOptions
      functions(first: 1000) {
        selector
        executionOptions
        wildcarded
        condition {
          id
          json
        }
      }
    }
    annotations(first: 1000) {
      uri
      schema
    }
    lastUpdate
  }
}
`.trim();
const getRoleId = (address, roleKey) => `${address.toLowerCase()}-ROLE-${roleKey}`;
export const fetchRole = async ({ address, roleKey, blockNumber, ...rest }, options) => {
    const endpoint = "subgraph" in rest ? rest.subgraph : chains[rest.chainId].subgraph;
    const res = await fetch(endpoint, {
        ...options,
        method: "POST",
        headers: {
            ...options?.headers,
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            query: blockNumber ? ROLE_AT_BLOCK_QUERY : ROLE_QUERY,
            variables: { id: getRoleId(address, roleKey), block: blockNumber },
            operationName: "Role",
        }),
    });
    const { data, error, errors } = await res.json();
    if (error || (errors && errors[0])) {
        throw new Error(error || errors[0]);
    }
    if (!data || !data.role) {
        return null;
    }
    assertNoPagination(data.role.members);
    assertNoPagination(data.role.targets);
    assertNoPagination(data.role.annotations);
    return mapGraphQl(data.role);
};
const mapGraphQl = (role) => ({
    ...role,
    members: role.members.map((assignment) => assignment.member.address),
    targets: role.targets.map((target) => ({
        address: target.address,
        clearance: Clearance[target.clearance],
        executionOptions: ExecutionOptions[target.executionOptions],
        functions: target.functions.map((func) => ({
            selector: func.selector,
            executionOptions: ExecutionOptions[func.executionOptions],
            wildcarded: func.wildcarded,
            condition: func.condition && JSON.parse(func.condition.json),
        })),
    })),
});
const assertNoPagination = (data) => {
    if (data.length === 1000) {
        throw new Error("Pagination not supported");
    }
};
