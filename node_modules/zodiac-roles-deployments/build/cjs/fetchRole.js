"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchRole = void 0;
const chains_1 = require("./chains");
const types_1 = require("./types");
const ROLE_QUERY = `
query Role($id: String) {
  role(id: $id) {
    key
    members(first: 1000) {
      member {
        address
      }
    }
    targets(first: 1000) {
      address
      clearance
      executionOptions
      functions(first: 1000) {
        selector
        executionOptions
        wildcarded
        condition {
          id
          json
        }
      }
    }
    annotations(first: 1000) {
      uri
      schema
    }
    lastUpdate
  }
}
`.trim();
const ROLE_AT_BLOCK_QUERY = `
query Role($id: String, $block: Int) {
  role(id: $id, block: { number: $block }) {
    key
    members(first: 1000) {
      member {
        address
      }
    }
    targets(first: 1000) {
      address
      clearance
      executionOptions
      functions(first: 1000) {
        selector
        executionOptions
        wildcarded
        condition {
          id
          json
        }
      }
    }
    annotations(first: 1000) {
      uri
      schema
    }
    lastUpdate
  }
}
`.trim();
const getRoleId = (address, roleKey) => `${address.toLowerCase()}-ROLE-${roleKey}`;
const fetchRole = async (_a, options) => {
    var { address, roleKey, blockNumber } = _a, rest = __rest(_a, ["address", "roleKey", "blockNumber"]);
    const endpoint = "subgraph" in rest ? rest.subgraph : chains_1.chains[rest.chainId].subgraph;
    const res = await fetch(endpoint, Object.assign(Object.assign({}, options), { method: "POST", headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { "Content-Type": "application/json" }), body: JSON.stringify({
            query: blockNumber ? ROLE_AT_BLOCK_QUERY : ROLE_QUERY,
            variables: { id: getRoleId(address, roleKey), block: blockNumber },
            operationName: "Role",
        }) }));
    const { data, error, errors } = await res.json();
    if (error || (errors && errors[0])) {
        throw new Error(error || errors[0]);
    }
    if (!data || !data.role) {
        return null;
    }
    assertNoPagination(data.role.members);
    assertNoPagination(data.role.targets);
    assertNoPagination(data.role.annotations);
    return mapGraphQl(data.role);
};
exports.fetchRole = fetchRole;
const mapGraphQl = (role) => (Object.assign(Object.assign({}, role), { members: role.members.map((assignment) => assignment.member.address), targets: role.targets.map((target) => ({
        address: target.address,
        clearance: types_1.Clearance[target.clearance],
        executionOptions: types_1.ExecutionOptions[target.executionOptions],
        functions: target.functions.map((func) => ({
            selector: func.selector,
            executionOptions: types_1.ExecutionOptions[func.executionOptions],
            wildcarded: func.wildcarded,
            condition: func.condition && JSON.parse(func.condition.json),
        })),
    })) }));
const assertNoPagination = (data) => {
    if (data.length === 1000) {
        throw new Error("Pagination not supported");
    }
};
