"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchRolesMod = void 0;
const chains_1 = require("./chains");
const types_1 = require("./types");
const QUERY = `
  query RolesMod($id: String) {
    rolesModifier(id: $id) {
      address
      owner
      avatar
      target 
      roles(first: 1000) {
        key
        members(first: 1000) {
          member {
            address
          }
        }
        targets(first: 1000) {
          address
          clearance
          executionOptions
          functions(first: 1000) {
            selector
            wildcarded
            executionOptions
          }
        }
        lastUpdate
      }
      allowances(first: 1000) {
        key
        refill
        maxRefill
        period
        balance
        timestamp
      }
      unwrapAdapters(
        where: {
          selector: "0x8d80ff0a", 
          adapterAddress: "0x93b7fcbc63ed8a3a24b59e1c3e6649d50b7427c0"
        }
      ) {
        targetAddress
      }
    }
  }
`;
const fetchRolesMod = async (_a, options) => {
    var { address } = _a, rest = __rest(_a, ["address"]);
    const endpoint = "subgraph" in rest ? rest.subgraph : chains_1.chains[rest.chainId].subgraph;
    const res = await fetch(endpoint, Object.assign(Object.assign({}, options), { method: "POST", headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { "Content-Type": "application/json" }), body: JSON.stringify({
            query: QUERY,
            variables: { id: address.toLowerCase() },
            operationName: "RolesMod",
        }) }));
    const { data, error, errors } = await res.json();
    if (error || (errors && errors[0])) {
        throw new Error(error || errors[0]);
    }
    if (!data || !data.rolesModifier) {
        return null;
    }
    assertNoPagination(data.rolesModifier.roles);
    for (const role of data.rolesModifier.roles) {
        assertNoPagination(role.members);
        assertNoPagination(role.targets);
    }
    return mapGraphQl(data.rolesModifier);
};
exports.fetchRolesMod = fetchRolesMod;
const mapGraphQl = (rolesModifier) => (Object.assign(Object.assign({}, rolesModifier), { roles: rolesModifier.roles.map(mapGraphQlRole), allowances: rolesModifier.allowances.map((allowance) => ({
        key: allowance.key,
        refill: BigInt(allowance.refill),
        maxRefill: BigInt(allowance.maxRefill),
        period: BigInt(allowance.period),
        balance: BigInt(allowance.balance),
        timestamp: BigInt(allowance.timestamp),
    })), multiSendAddresses: rolesModifier.unwrapAdapters.map((adapter) => adapter.targetAddress) }));
const mapGraphQlRole = (role) => ({
    key: role.key,
    members: role.members.map((assignment) => assignment.member.address),
    targets: role.targets
        .filter((t) => t.clearance !== "None" &&
        !(t.clearance === "Function" && t.functions.length === 0))
        .map((target) => ({
        address: target.address,
        clearance: types_1.Clearance[target.clearance],
        executionOptions: types_1.ExecutionOptions[target.executionOptions],
        functions: target.functions.map((func) => ({
            selector: func.selector,
            executionOptions: types_1.ExecutionOptions[func.executionOptions],
            wildcarded: func.wildcarded,
        })),
    })),
});
const assertNoPagination = (data) => {
    if (data.length === 1000) {
        throw new Error("Pagination not supported");
    }
};
